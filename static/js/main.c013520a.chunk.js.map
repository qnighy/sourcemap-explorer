{"version":3,"sources":["parse.ts","diff_memo.ts","App.tsx","uploader.ts","reportWebVitals.ts","index.tsx"],"names":["initResult","files","Map","sourceFiles","parseFile","name","content","match","sourceMap","parseSourceMap","sourceMapRef","contentText","TextDecoder","decode","matchJS","matchCSS","json","JSON","parse","Array","isArray","Error","version","file","sourceRoot","sources","sourcesContent","names","mappings","isArrayOf","isString","isStringOrNull","parseMappings","x","arr","pred","equalFiles","files1","files2","from","keys","concat","get","mappings_","lines","segments","lastColumn","lastSourceIndex","lastSourceLine","lastSourceColumn","lastNameIndex","currentSegment","current","currentBits","i","length","charCode","charCodeAt","b","base64val","push","columnDiff","toSigned","column","source","sourceLine","sourceColumn","undefined","n","equalDeps","deps1","deps2","FileListEntry","props","selected","removeFile","selectFile","removeThisFile","useCallback","selectThisFile","classNames","filter","Boolean","className","join","onClick","state","icon","faCheck","faTrash","FileListAddButton","useDropzone","onDrop","getRootProps","getInputProps","isDragActive","SourceMappedText","text","split","map","line","lineno","highlight","openRight","SourceMappedLine","mapping","nextColumn","segmentText","substring","SourceMappedSegment","openThisRight","inverseMappings","sourceName","newMappings","entries","segment","sort","a","App","uploaderState","useState","userFiles","setUserFiles","produce","delete","acceptedFiles","set","arrayBuffer","oldFileState","uploadedFiles","useUploader","parseResult","f","deps","useRef","value","useDebugValue","useDiffMemo","prev","uploadedFile","prevFile","values","sourceContent","TextEncoder","encode","has","parseFiles","leftFilelistOpen","setLeftFilelistOpen","rightFilelistOpen","setRightFilelistOpen","selectedLeft","setSelectedLeft","selectedRight","setSelectedRight","selectSegmentLeft","setSelectSegmentLeft","highlightRight","setHighlightRight","selectRightFile","selectedLeftFile","selectedLeftParsed","selectedRightFile","inversedMappings","useMemo","faChevronDown","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","enableMapSet","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"+SAOMA,G,MAAa,iBAAoB,CACrCC,MAAO,IAAIC,IACXC,YAAa,IAAID,OA0FbE,EAAY,SAACC,EAAcC,GAC/B,GAAID,EAAKE,MAAM,UACb,MAAO,CACLD,UACAE,UAAWC,EAAeH,IAG9B,IAAII,EACEC,GAAc,IAAIC,aAAcC,OAAOP,GACvCQ,EAAUH,EAAYJ,MAAM,kCAC5BQ,EAAWJ,EAAYJ,MAAM,uCAMnC,OALIO,EACFJ,EAAeI,EAAQ,GACdC,IACTL,EAAeK,EAAS,IAEnB,CAAET,UAASI,iBAGdD,EAAiB,SAACH,GACtB,IAAMU,EAAgBC,KAAKC,OAAM,IAAIN,aAAcC,OAAOP,IAC1D,GAAoB,kBAATU,GAA8B,OAATA,GAAiBG,MAAMC,QAAQJ,GAC7D,MAAM,IAAIK,MAAM,iCAGlB,IANiE,EAe7DL,EAPFM,EAR+D,EAQ/DA,QACAC,EAT+D,EAS/DA,KACAC,EAV+D,EAU/DA,WACAC,EAX+D,EAW/DA,QACAC,EAZ+D,EAY/DA,eACAC,EAb+D,EAa/DA,MACAC,EAd+D,EAc/DA,SAEF,GAAgB,IAAZN,EACF,MAAM,IAAID,MAAM,mBAElB,GAAoB,qBAATE,GAAwC,kBAATA,EACxC,MAAM,IAAIF,MAAM,yBAElB,GAA0B,qBAAfG,GAAoD,kBAAfA,EAC9C,MAAM,IAAIH,MAAM,+BAElB,IAAKQ,EAAUJ,EAASK,GACtB,MAAM,IAAIT,MAAM,uCAElB,GAC4B,qBAAnBK,IACNG,EAAUH,EAAgBK,GAE3B,MAAM,IAAIV,MAAM,uDAElB,IAAKQ,EAAUF,EAAOG,GACpB,MAAM,IAAIT,MAAM,qCAElB,GAAwB,kBAAbO,EACT,MAAM,IAAIP,MAAM,6BAElB,MAAO,CACLC,UACAC,OACAC,aACAC,UACAC,iBACAE,SAAUI,EAAcJ,EAAUH,EAASE,KAIzCG,EAAW,SAACG,GAAD,MAA0C,kBAANA,GAC/CF,EAAiB,SAACE,GAAD,MACR,kBAANA,GAAwB,OAANA,GAErBJ,EAAY,SAChBK,EACAC,GAEA,IAAKhB,MAAMC,QAAQc,GACjB,OAAO,EAFM,oBAIIA,GAJJ,IAIf,2BAAwB,CACtB,IAAKC,EADiB,SACL,OAAO,GALX,8BAOf,OAAO,GAGHC,EAAa,SACjBC,EACAC,GACa,IAAD,gBACOnB,MAAMoB,KAAKF,EAAOG,QAAQC,OAC3CtB,MAAMoB,KAAKD,EAAOE,UAFR,IACZ,2BAEG,CAAC,IAFOnC,EAER,QACD,GAAIgC,EAAOK,IAAIrC,KAAUiC,EAAOI,IAAIrC,GAClC,OAAO,GALC,8BAQZ,OAAO,GAGH2B,EAAgB,SACpBW,EACAlB,EACAE,GAaA,IAXA,IAAMC,EAAWe,EAAY,IACvBC,EAAqB,GACvBC,EAAsB,GACtBC,EAAa,EACbC,EAAkB,EAClBC,EAAiB,EACjBC,EAAmB,EACnBC,EAAgB,EAChBC,EAA2B,GAC3BC,EAAU,EACVC,EAAc,EACTC,EAAI,EAAGA,EAAI1B,EAAS2B,OAAQD,IAAK,CACxC,IAAME,EAAW5B,EAAS6B,WAAWH,GACrC,GAAiB,KAAbE,GAA0C,KAAbA,EAAjC,CAyCA,IAAME,EAAIC,EAAUH,GAChBE,EAAI,IACNP,EAAeS,KAAKR,EAAWM,GAAKL,GACpCD,EAAU,EACVC,EAAc,IAEdD,IAAgB,GAAJM,IAAWL,EACvBA,GAAe,OAhDjB,CACE,GAAgB,IAAZD,GAAiC,IAAhBC,EAAmB,MAAM,IAAIhC,MAAM,eACxD,GAA8B,IAA1B8B,EAAeI,QAA6B,KAAbC,EAA2B,CAC5DZ,EAAMgB,KAAKf,GACXA,EAAW,GACXC,EAAa,EACb,SAEF,GAA8B,IAA1BK,EAAeI,OAAc,MAAM,IAAIlC,MAAM,qBACjD,IAAMwC,EAAaC,EAASX,EAAe,IAC3C,GAAIU,EAAa,EAAG,MAAM,IAAIxC,MAAM,4BAEpC,GADAyB,GAAce,EACgB,IAA1BV,EAAeI,QAA0C,IAA1BJ,EAAeI,OAIhDR,GAHwBe,EAASX,EAAe,IAIhDH,GAHuBc,EAASX,EAAe,IAI/CF,GAHyBa,EAASX,EAAe,IAInB,IAA1BA,EAAeI,SACjBL,GAAiBY,EAASX,EAAe,UAEtC,GAA8B,IAA1BA,EAAeI,OACxB,MAAM,IAAIlC,MAAM,0BAElBwB,EAASe,KAAK,CACZG,OAAQjB,EAERkB,OAAQvC,EAAQsB,GAChBkB,WAAYjB,EACZkB,aAAcjB,EACd5C,KAAgC,IAA1B8C,EAAeI,OAAe5B,EAAMuB,QAAiBiB,IAE7DhB,EAAiB,GACA,KAAbK,IACFZ,EAAMgB,KAAKf,GACXA,EAAW,GACXC,EAAa,IAcnB,OAAOF,GAGHe,EAAY,SAACH,GACjB,GAAIA,GAAY,IAAgBA,GAAY,GAC1C,OAAOA,EAAW,GACb,GAAIA,GAAY,IAAgBA,GAAY,IACjD,OAAOA,EAAQ,GACV,GAAIA,GAAY,IAAgBA,GAAY,GACjD,OAAOA,EAAQ,EACV,GAAiB,KAAbA,EACT,OAAO,GACF,GAAiB,KAAbA,EACT,OAAO,GAEP,MAAM,IAAInC,MAAJ,gCAAmCmC,KAIvCM,EAAW,SAACM,GAChB,OAAQ,EAAJA,IACOA,GAAK,GAEPA,GAAK,GCvQVC,EAAY,SAACC,EAAkBC,GACnC,GAAID,EAAMf,SAAWgB,EAAMhB,OAAQ,OAAO,EAC1C,IAAK,IAAID,EAAI,EAAGA,EAAIgB,EAAMf,OAAQD,IAChC,GAAIgB,EAAMhB,KAAOiB,EAAMjB,GACrB,OAAO,EAGX,OAAO,GC0IHkB,EAA8C,SAACC,GAAW,IACtDpE,EAAiDoE,EAAjDpE,KAAMkB,EAA2CkD,EAA3ClD,KAAMmD,EAAqCD,EAArCC,SAAUC,EAA2BF,EAA3BE,WAAYC,EAAeH,EAAfG,WACpCC,EAAiBC,uBAAY,kBAAMH,EAAWtE,KAAO,CACzDA,EACAsE,IAEII,EAAiBD,uBAAY,kBAAMF,GAAcA,EAAWvE,KAAO,CACvEA,EACAuE,IAEII,EAAa,CACjB,kBACAN,EAAW,gBAAaP,GACxBc,OAAOC,SACT,OACE,qBAAIC,UAAWH,EAAWI,KAAK,KAAMC,QAASN,EAA9C,UACE,sBAAKI,UAAU,wBAAf,UACG9E,EACe,cAAfkB,EAAK+D,MAAwB,MAAQ,MAExB,cAAf/D,EAAK+D,OAAwC,aAAf/D,EAAK+D,MAClC,qCACE,wBAAQH,UAAU,mBAAmBE,QAASN,EAA9C,SACE,cAAC,IAAD,CAAiBQ,KAAMC,QAEzB,wBAAQL,UAAU,mBAAmBE,QAASR,EAA9C,SACE,cAAC,IAAD,CAAiBU,KAAME,WAGzB,SASJC,EAAsD,SAACjB,GAAW,IAAD,EACfkB,YAAY,CAChEC,OAAQnB,EAAMmB,SADRC,EAD6D,EAC7DA,aAAcC,EAD+C,EAC/CA,cAAeC,EADgC,EAChCA,aAGrC,OACE,6CAAIZ,UAAU,wBAA2BU,KAAzC,cACE,qCAAWC,MACVC,EACC,0DAEA,gGAgBFC,EAAoD,SAACvB,GAAW,IAAD,EAC7D7C,EAAQ,UAAG6C,EAAM7C,gBAAT,QAAqB,GACnC,OACE,qBAAKuD,UAAU,yBAAf,SACE,+BACGV,EAAMwB,KAAKC,MAAM,MAAMC,KAAI,SAACC,EAAMC,GAAP,OAC1B,cAAC,EAAD,CAEEA,OAAQA,EACRD,KAAMA,EACNxE,SAAUA,EAASyE,GACnBC,UACE7B,EAAM6B,WACF7B,EAAM6B,UAAU,KAAOD,EACrB5B,EAAM6B,UAAU,QAElBnC,EAENoC,UAAW9B,EAAM8B,WAXZF,WA8BXG,EAAoD,SAAC/B,GAAW,IAAD,EAC/D7C,EAAQ,UAAG6C,EAAM7C,gBAAT,QAAqB,GAIjC,OAHwB,IAApBA,EAAS2B,QAAgB3B,EAAS,GAAGmC,OAAS,KAChDnC,EAAW,CAAC,CAAEmC,OAAQ,IAAKtB,OAAOb,IAGlC,qCACGA,EAASuE,KAAI,SAACM,EAASnD,GAAO,IAAD,IACtBoD,EAAU,oBAAG9E,EAAS0B,EAAI,UAAhB,aAAG,EAAiBS,cAApB,QAA8BU,EAAM2B,KAAK7C,OACzD,GAAIkD,EAAQ1C,QAAU2C,EAAY,OAAO,KACzC,IAAMC,EAAclC,EAAM2B,KAAKQ,UAAUH,EAAQ1C,OAAQ2C,GACzD,OACE,cAAC,EAAD,CAEEL,OAAQ5B,EAAM4B,OACdM,YAAaA,EACbF,QAASA,EACTH,UAAW7B,EAAM6B,YAAcG,EAAQ1C,OACvCwC,UAAW9B,EAAM8B,WALZE,EAAQ1C,WASlB,SAgBD8C,EAA0D,SAACpC,GAAW,IAClEkC,EAA+ClC,EAA/CkC,YAAaF,EAAkChC,EAAlCgC,QAASH,EAAyB7B,EAAzB6B,UAAWC,EAAc9B,EAAd8B,UACnCO,EAAgBhC,uBAAY,WAC5ByB,GAAaE,EAAQzC,QACvBuC,EAAUE,EAAQzC,OAAQ,CACxB,CAACS,EAAM4B,OAAQI,EAAQ1C,QACvB,CAAC0C,EAAQxC,WAAYwC,EAAQvC,kBAGhC,CACDqC,EACAE,EAAQzC,OACRS,EAAM4B,OACNI,EAAQ1C,OACR0C,EAAQxC,WACRwC,EAAQvC,eAEV,OAAIuC,EAAQzC,OAER,sBACEmB,UAAWmB,EAAY,2BAA6B,iBACpDjB,QAASyB,EAFX,SAIGH,IAIE,sBAAMxB,UAAU,mBAAhB,SAAoCwB,KAIzCI,EAAkB,SACtB1G,EACA2G,EACApF,GAGA,IADA,IAAMqF,EAAiC,GACvC,MAA6B9F,MAAMoB,KAAKX,EAASsF,WAAjD,eAA6D,CAAC,IAAD,wBAAjDb,EAAiD,KAAzCD,EAAyC,mBACrCA,GADqC,IAC3D,2BAA4B,CAAC,IAAlBe,EAAiB,QAC1B,GAAKA,EAAQnD,QACTmD,EAAQnD,SAAWgD,EAAvB,CACA,KAAOC,EAAY1D,QAAU4D,EAAQlD,YAAYgD,EAAYrD,KAAK,IAClEqD,EAAYE,EAAQlD,YAAYL,KAAK,CACnCG,OAAQoD,EAAQjD,aAChBF,OAAQ3D,EACR4D,WAAYoC,EACZnC,aAAciD,EAAQpD,WATiC,+BAa7D,cAAmBkD,EAAnB,eAAgC,CAAjB,KACRG,MAAK,SAACC,EAAG3D,GACZ,OAAI2D,EAAEtD,SAAWL,EAAEK,OAAesD,EAAEtD,OAASL,EAAEK,QAE3CsD,EAAEpD,WAAeP,EAAEO,WAAmBoD,EAAEpD,WAAaP,EAAEO,eAI/D,OAAOgD,GAGMK,EAvWO,WAAO,IAAD,IACpBC,ECJmB,WAqDzB,IArD+C,IAAD,EACZC,oBAChC,kBAAM,IAAItH,OAFkC,mBACvCuH,EADuC,KAC5BC,EAD4B,KAIxC/C,EAAaG,uBACjB,SAACzE,GACCqH,GAAa,SAACpC,GAAD,OACXqC,YAAQrC,GAAO,SAACA,GACdA,EAAMsC,OAAOvH,WAInB,CAACqH,IAEG9B,EAASd,uBACb,SAAC+C,GACCH,GAAa,SAACpC,GAAD,OACXqC,YAAQrC,GAAO,SAACA,GAAW,IAAD,gBACLuC,GADK,IACxB,2BAAkC,CAAC,IAAD,EAAvBtG,EAAuB,QAChC+D,EAAMwC,IAAIvG,EAAKlB,KAAM,CACnBiF,MAAO,YACP/D,OACAjB,QAAO,UAAEgF,EAAM5C,IAAInB,EAAKlB,aAAjB,aAAE,EAAsBC,WALX,qCAFH,oBAYNuH,GAZM,IAYzB,2BAAkC,CAAC,IAAxBtG,EAAuB,SAChC,uCAAC,WAAOA,GAAP,eAAA8F,EAAA,sEACuB9F,EAAKwG,cAD5B,OACOzH,EADP,OAECoH,GAAa,SAACpC,GAAD,OACXqC,YAAQrC,GAAO,SAACA,GACd,IAAM0C,EAAe1C,EAAM5C,IAAInB,EAAKlB,MAEjC2H,GACsB,cAAvBA,EAAa1C,OACb0C,EAAazG,OAASA,GAIxB+D,EAAMwC,IAAIvG,EAAKlB,KAAM,CACnBiF,MAAO,WACPhF,kBAdP,2CAAD,sDAkBGiB,IA/BoB,iCAkC3B,CAACmG,IAGGO,EAAgD,IAAI/H,IAC1D,MAA2BiB,MAAMoB,KAAKkF,EAAUP,WAAhD,eAA4D,CAAC,IAAD,sBAAhD7G,EAAgD,KAA1CkB,EAA0C,KACtDA,EAAKjB,SACP2H,EAAcH,IAAIzH,EAAM,CACtBiF,MAAO,WACPhF,QAASiB,EAAKjB,UAKpB,MAAO,CACL2H,gBACAR,YACA9C,aACAiB,UD9DoBsC,GAChBC,EDTmB,SAAIC,EAAoBC,GACjD,IAAM/C,EAAQgD,iBAAgC,MAC9C,GAAsB,OAAlBhD,EAAMlC,QAAkB,CAC1B,IAAMmF,EAAQH,IAId,OAHA9C,EAAMlC,QAAU,CAAEiF,OAAME,SAExBC,wBAAcD,GACPA,EACF,GAAKlE,EAAUiB,EAAMlC,QAAQiF,KAAMA,GASxC,OADAG,wBAAclD,EAAMlC,QAAQmF,OACrBjD,EAAMlC,QAAQmF,MARrB,IAAMA,EAAQH,EAAE9C,EAAMlC,QAAQmF,OAI9B,OAHAjD,EAAMlC,QAAU,CAAEiF,OAAME,SAExBC,wBAAcD,GACPA,ECJWE,EAClB,SAACC,GAAD,OF0BsB,SACxBT,GAIA,IAFiB,IADjBS,EACgB,uDADI1I,IAEdC,EAAQ,IAAIC,IAClB,MAAmCiB,MAAMoB,KAAK0F,EAAcf,WAA5D,eAAwE,CAAC,IAAD,sBAA5D7G,EAA4D,KAAtDsI,EAAsD,KAChEC,EAAWF,EAAKzI,MAAMyC,IAAIrC,GAC5BuI,GAAYA,EAAStI,UAAYqI,EAAarI,QAChDL,EAAM6H,IAAIzH,EAAMuI,GAEhB3I,EAAM6H,IAAIzH,EAAMD,EAAUC,EAAMsI,EAAarI,UAKjD,GAAI8B,EAAWsG,EAAKzI,MAAOA,GACzB,OAAOyI,EAIT,IADA,IAAMvI,EAAc,IAAID,IACxB,MAAmBiB,MAAMoB,KAAKtC,EAAM4I,UAApC,eAA+C,CAA1C,IAAMtH,EAAI,KACb,GAAIA,EAAKf,UAAW,CAAC,IAAD,gBACGe,EAAKf,UAAUiB,SADlB,IAClB,2BAA6C,CAAC,IAAnCuC,EAAkC,QAE3C7D,EAAY2H,IAAI9D,EAAQ,CAAEsB,MAAO,aAHjB,gCAOtB,cAAmBnE,MAAMoB,KAAKtC,EAAM4I,UAApC,eAA+C,CAA1C,IAAMtH,EAAI,KACb,GAAIA,EAAKf,WAAae,EAAKf,UAAUkB,eACnC,cAA0BP,MAAMoB,KAAKhB,EAAKf,UAAUiB,QAAQyF,WAA5D,eAAwE,CAAC,IAAD,sBAA5D5D,EAA4D,KAAzDU,EAAyD,KAEhE8E,EAAgBvH,EAAKf,UAAUkB,eAAe4B,GAChDwF,GACF3I,EAAY2H,IAAI9D,EAAQ,CACtBsB,MAAO,UACPhF,SAAS,IAAIyI,aAAcC,OAAOF,MAM5C,cAAmC3H,MAAMoB,KAAK0F,EAAcf,WAA5D,eAAwE,CAAC,IAAD,sBAA5D7G,EAA4D,KAAtDsI,EAAsD,KAClExI,EAAY8I,IAAI5I,IAClBF,EAAY2H,IAAIzH,EAAM,CACpBiF,MAAO,WACPhF,QAASqI,EAAarI,UAI5B,MAAO,CACLL,QACAE,eE9EwB+I,CAAW3B,EAAcU,cAAeS,KAChE,CAACnB,EAAcU,gBAJS,EAOsBT,oBAAS,GAP/B,mBAOnB2B,EAPmB,KAODC,EAPC,OAQwB5B,oBAAS,GARjC,mBAQnB6B,EARmB,KAQAC,EARA,OAUc9B,qBAVd,mBAUnB+B,EAVmB,KAULC,EAVK,OAWgBhC,qBAXhB,mBAWnBiC,EAXmB,KAWJC,EAXI,KAYpB9E,EAAaE,uBACjB,SAACzE,GACC+I,GAAoB,GACpBI,EAAgBnJ,KAElB,CAAC+I,EAAqBI,IAjBE,EAmBwBhC,qBAnBxB,mBAmBnBmC,EAnBmB,KAmBAC,EAnBA,OAsBkBpC,qBAtBlB,mBAsBnBqC,EAtBmB,KAsBHC,EAtBG,KAyBpBC,EAAkBjF,uBACtB,SAACzE,EAAciG,GACbgD,GAAqB,GACrBI,EAAiBrJ,GACjBuJ,EAAqBtD,EAAYA,EAAU,QAAKnC,GAChD2F,EAAkBxD,EAAYA,EAAU,QAAKnC,KAE/C,CAACmF,EAAsBI,IAEnBM,OACa7F,IAAjBoF,EACIhC,EAAcU,cAAcvF,IAAI6G,QAChCpF,EACA8F,OACa9F,IAAjBoF,EACIpB,EAAYlI,MAAMyC,IAAI6G,QACtBpF,EACA+F,OACc/F,IAAlBsF,EACItB,EAAYhI,YAAYuC,IAAI+G,QAC5BtF,EAEAvC,GAA6B,OAAlBqI,QAAkB,IAAlBA,OAAA,EAAAA,EAAoBvJ,cAApB,UACbyH,EAAYlI,MAAMyC,IAAIuH,EAAmBvJ,qBAD5B,iBACb,EAAwDF,iBAD3C,aACb,EACIoB,cACJuC,EACEgG,EAAmBC,mBAAiC,WACxD,OAAIb,GAAgBE,GAAiB7H,EAC5BmF,EAAgBwC,EAAcE,EAAe7H,QAEpD,IAED,CAAC2H,EAAcE,EAAe7H,IACjC,OACE,sBAAKuD,UAAU,MAAf,UACE,oDACA,sBAAKA,UAAU,SAAf,UACE,sBAAKA,UAAU,mBAAf,UACE,qBACEA,UACE6E,IAAqBb,EACjB,mBACA,YAJR,UAOGhI,MAAMoB,KAAKgF,EAAcE,UAAUP,WAAWf,KAC7C,mCAAE9F,EAAF,KAAQkB,EAAR,YACE,cAAC,EAAD,CAEElB,KAAMA,EACNkB,KAAMA,EACNmD,SAAUrE,IAASkJ,EACnB3E,WAAYA,EACZD,WAAY4C,EAAc5C,YALrBtE,MASX,cAAC,EAAD,CAAmBuF,OAAQ2B,EAAc3B,YAE1CoE,EACC,qCACE,sBACE7E,UAAU,eACVE,QAAS,kBAAM+D,GAAoB,IAFrC,UAIE,qBAAKjE,UAAU,qBAAf,SAAqCoE,IACrC,wBAAQlE,QAAS,kBAAM+D,GAAoB,IAA3C,SACE,cAAC,IAAD,CAAiB7D,KAAM8E,WAG3B,cAAC,EAAD,CACEpE,MAAM,IAAIrF,aAAcC,OAAOmJ,EAAiB1J,SAChDsB,SAAUA,EACV2E,UAAWwD,EACXzD,UAAWqD,OAGb,QAEN,sBAAKxE,UAAU,gBAAf,UACE,oBACEA,UACE+E,GAC4B,YAA5BA,EAAkB5E,QACjB+D,EACG,mBACA,YANR,SASGlI,MAAMoB,KAAK4F,EAAYhI,YAAY+G,WAAWf,KAC7C,mCAAE9F,EAAF,KAAQkB,EAAR,YACE,cAAC,EAAD,CAEElB,KAAMA,EACNkB,KAAMA,EACNmD,UAAU,EACVE,WAAYmF,EACZpF,WAAY4C,EAAc5C,YALrBtE,QAUZ6J,GAAiD,YAA5BA,EAAkB5E,MACtC,qCACE,sBACEH,UAAU,eACVE,QAAS,kBAAMiE,GAAqB,IAFtC,UAIE,qBAAKnE,UAAU,qBAAf,SAAqCsE,IACrC,wBAAQpE,QAAS,kBAAMiE,GAAqB,IAA5C,SACE,cAAC,IAAD,CAAiB/D,KAAM8E,WAG3B,cAAC,EAAD,CACEpE,MAAM,IAAIrF,aAAcC,OAAOqJ,EAAkB5J,SACjDsB,SAAUuI,EACV7D,UAAWuD,OAGb,eEhJCS,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCFdQ,cAEAC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bd,M","file":"static/js/main.c013520a.chunk.js","sourcesContent":["import { SourceFileState, UploadedFileState } from \"./file_states\";\n\nexport interface ParseResult {\n  files: Map<string, ParsedFile>;\n  sourceFiles: Map<string, SourceFileState>;\n}\n\nconst initResult = (): ParseResult => ({\n  files: new Map(),\n  sourceFiles: new Map(),\n});\n\nexport interface ParsedFile {\n  content: ArrayBuffer;\n  sourceMap?: SourceMapContent;\n  sourceMapRef?: string;\n}\n\nexport interface SourceMapContent {\n  version: 3;\n  file?: string;\n  sourceRoot?: string;\n  sources: string[];\n  sourcesContent?: (string | null)[];\n  mappings: Segment[][];\n}\n\nexport interface UnmappedSegment {\n  column: number;\n  source?: undefined;\n  sourceLine?: undefined;\n  sourceColumn?: undefined;\n  name?: undefined;\n}\nexport interface MappedSegment {\n  column: number;\n  source: string;\n  sourceLine: number;\n  sourceColumn: number;\n  name?: string;\n}\nexport type Segment = UnmappedSegment | MappedSegment;\n\nexport const parseFiles = (\n  uploadedFiles: Map<string, UploadedFileState>,\n  prev: ParseResult = initResult()\n): ParseResult => {\n  const files = new Map<string, ParsedFile>();\n  for (const [name, uploadedFile] of Array.from(uploadedFiles.entries())) {\n    const prevFile = prev.files.get(name);\n    if (prevFile && prevFile.content === uploadedFile.content) {\n      files.set(name, prevFile);\n    } else {\n      files.set(name, parseFile(name, uploadedFile.content));\n    }\n  }\n\n  // Return prev if nothing has been changed.\n  if (equalFiles(prev.files, files)) {\n    return prev;\n  }\n\n  const sourceFiles = new Map<string, SourceFileState>();\n  for (const file of Array.from(files.values())) {\n    if (file.sourceMap) {\n      for (const source of file.sourceMap.sources) {\n        // TODO: sourceRoot\n        sourceFiles.set(source, { state: \"missing\" });\n      }\n    }\n  }\n  for (const file of Array.from(files.values())) {\n    if (file.sourceMap && file.sourceMap.sourcesContent) {\n      for (const [i, source] of Array.from(file.sourceMap.sources.entries())) {\n        // TODO: sourceRoot\n        const sourceContent = file.sourceMap.sourcesContent[i];\n        if (sourceContent) {\n          sourceFiles.set(source, {\n            state: \"bundled\",\n            content: new TextEncoder().encode(sourceContent),\n          });\n        }\n      }\n    }\n  }\n  for (const [name, uploadedFile] of Array.from(uploadedFiles.entries())) {\n    if (sourceFiles.has(name)) {\n      sourceFiles.set(name, {\n        state: \"uploaded\",\n        content: uploadedFile.content,\n      });\n    }\n  }\n  return {\n    files,\n    sourceFiles,\n  };\n};\n\nconst parseFile = (name: string, content: ArrayBuffer): ParsedFile => {\n  if (name.match(/\\.map$/)) {\n    return {\n      content,\n      sourceMap: parseSourceMap(content),\n    };\n  }\n  let sourceMapRef: string | undefined;\n  const contentText = new TextDecoder().decode(content);\n  const matchJS = contentText.match(/^\\/\\/# sourceMappingURL=(.*)$/m);\n  const matchCSS = contentText.match(/^\\/\\*# sourceMappingURL=(.*) \\*\\/$/m);\n  if (matchJS) {\n    sourceMapRef = matchJS[1];\n  } else if (matchCSS) {\n    sourceMapRef = matchCSS[1];\n  }\n  return { content, sourceMapRef };\n};\n\nconst parseSourceMap = (content: ArrayBuffer): SourceMapContent => {\n  const json: unknown = JSON.parse(new TextDecoder().decode(content));\n  if (typeof json !== \"object\" || json === null || Array.isArray(json)) {\n    throw new Error(\"SourecMap should be an object\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/ban-types\n  const _typecheck_json: object = json;\n  const {\n    version,\n    file,\n    sourceRoot,\n    sources,\n    sourcesContent,\n    names,\n    mappings,\n  } = json as { [key in string]?: unknown };\n  if (version !== 3) {\n    throw new Error(\"Invalid version\");\n  }\n  if (typeof file !== \"undefined\" && typeof file !== \"string\") {\n    throw new Error(\"file must be a string\");\n  }\n  if (typeof sourceRoot !== \"undefined\" && typeof sourceRoot !== \"string\") {\n    throw new Error(\"sourceRoot must be a string\");\n  }\n  if (!isArrayOf(sources, isString)) {\n    throw new Error(\"sources must be an array of strings\");\n  }\n  if (\n    typeof sourcesContent !== \"undefined\" &&\n    !isArrayOf(sourcesContent, isStringOrNull)\n  ) {\n    throw new Error(\"sourcesContent must be an array of strings or nulls\");\n  }\n  if (!isArrayOf(names, isString)) {\n    throw new Error(\"names must be an array of strings\");\n  }\n  if (typeof mappings !== \"string\") {\n    throw new Error(\"mappings must be a string\");\n  }\n  return {\n    version,\n    file,\n    sourceRoot,\n    sources,\n    sourcesContent,\n    mappings: parseMappings(mappings, sources, names),\n  };\n};\n\nconst isString = (x: unknown): x is string => typeof x === \"string\";\nconst isStringOrNull = (x: unknown): x is string | null =>\n  typeof x === \"string\" || x === null;\n\nconst isArrayOf = <T>(\n  arr: unknown,\n  pred: (x: unknown) => x is T\n): arr is T[] => {\n  if (!Array.isArray(arr)) {\n    return false;\n  }\n  for (const elem of arr) {\n    if (!pred(elem)) return false;\n  }\n  return true;\n};\n\nconst equalFiles = (\n  files1: Map<string, ParsedFile>,\n  files2: Map<string, ParsedFile>\n): boolean => {\n  for (const name of Array.from(files1.keys()).concat(\n    Array.from(files2.keys())\n  )) {\n    if (files1.get(name) !== files2.get(name)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst parseMappings = (\n  mappings_: string,\n  sources: string[],\n  names: string[]\n): Segment[][] => {\n  const mappings = mappings_ + \";\";\n  const lines: Segment[][] = [];\n  let segments: Segment[] = [];\n  let lastColumn = 0;\n  let lastSourceIndex = 0;\n  let lastSourceLine = 0;\n  let lastSourceColumn = 0;\n  let lastNameIndex = 0;\n  let currentSegment: number[] = [];\n  let current = 0;\n  let currentBits = 0;\n  for (let i = 0; i < mappings.length; i++) {\n    const charCode = mappings.charCodeAt(i);\n    if (charCode === 0x3b /* ; */ || charCode === 0x2c /* , */) {\n      if (current !== 0 || currentBits !== 0) throw new Error(\"VLQ runover\");\n      if (currentSegment.length === 0 && charCode === 0x3b /* ; */) {\n        lines.push(segments);\n        segments = [];\n        lastColumn = 0;\n        continue;\n      }\n      if (currentSegment.length === 0) throw new Error(\"Segment too short\");\n      const columnDiff = toSigned(currentSegment[0]);\n      if (columnDiff < 0) throw new Error(\"column must be monotonic\");\n      lastColumn += columnDiff;\n      if (currentSegment.length === 4 || currentSegment.length === 5) {\n        const sourceIndexDiff = toSigned(currentSegment[1]);\n        const sourceLineDiff = toSigned(currentSegment[2]);\n        const sourceColumnDiff = toSigned(currentSegment[3]);\n        lastSourceIndex += sourceIndexDiff;\n        lastSourceLine += sourceLineDiff;\n        lastSourceColumn += sourceColumnDiff;\n        if (currentSegment.length === 5) {\n          lastNameIndex += toSigned(currentSegment[4]);\n        }\n      } else if (currentSegment.length !== 1) {\n        throw new Error(\"Invalid segment length\");\n      }\n      segments.push({\n        column: lastColumn,\n        // TODO: check index\n        source: sources[lastSourceIndex],\n        sourceLine: lastSourceLine,\n        sourceColumn: lastSourceColumn,\n        name: currentSegment.length === 5 ? names[lastNameIndex] : undefined,\n      });\n      currentSegment = [];\n      if (charCode === 0x3b /* ; */) {\n        lines.push(segments);\n        segments = [];\n        lastColumn = 0;\n      }\n      continue;\n    }\n    const b = base64val(charCode);\n    if (b < 32) {\n      currentSegment.push(current | (b << currentBits));\n      current = 0;\n      currentBits = 0;\n    } else {\n      current |= (b & 31) << currentBits;\n      currentBits += 5;\n    }\n  }\n  return lines;\n};\n\nconst base64val = (charCode: number): number => {\n  if (charCode >= 0x41 /* A */ && charCode <= 0x5a /* Z */) {\n    return charCode - 0x41;\n  } else if (charCode >= 0x61 /* a */ && charCode <= 0x7a /* z */) {\n    return charCode - (0x61 - 26);\n  } else if (charCode >= 0x30 /* 0 */ && charCode <= 0x39 /* 9 */) {\n    return charCode + (52 - 0x30);\n  } else if (charCode === 0x2b /* + */) {\n    return 62;\n  } else if (charCode === 0x2f /* / */) {\n    return 63;\n  } else {\n    throw new Error(`Invalid base64 value: ${charCode}`);\n  }\n};\n\nconst toSigned = (n: number): number => {\n  if (n & 1) {\n    return -(n >> 1);\n  } else {\n    return n >> 1;\n  }\n};\n","import { useDebugValue, useRef } from \"react\";\n\ninterface DiffMemoState<T> {\n  deps: unknown[];\n  value: T;\n}\n\nexport const useDiffMemo = <T>(f: (prev?: T) => T, deps: unknown[]): T => {\n  const state = useRef<DiffMemoState<T> | null>(null);\n  if (state.current === null) {\n    const value = f();\n    state.current = { deps, value };\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue(value);\n    return value;\n  } else if (!equalDeps(state.current.deps, deps)) {\n    const value = f(state.current.value);\n    state.current = { deps, value };\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue(value);\n    return value;\n  } else {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue(state.current.value);\n    return state.current.value;\n  }\n};\n\nconst equalDeps = (deps1: unknown[], deps2: unknown[]): boolean => {\n  if (deps1.length !== deps2.length) return false;\n  for (let i = 0; i < deps1.length; i++) {\n    if (deps1[i] !== deps2[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n","import React, { useCallback, useMemo, useState } from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  faTrash,\n  faChevronDown,\n  faCheck,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { SourceFileState, UserFileState } from \"./file_states\";\nimport { useUploader } from \"./uploader\";\nimport \"./App.css\";\nimport { MappedSegment, parseFiles, ParseResult, Segment } from \"./parse\";\nimport { useDiffMemo } from \"./diff_memo\";\n\nconst App: React.FC = () => {\n  const uploaderState = useUploader();\n  const parseResult = useDiffMemo(\n    (prev?: ParseResult) => parseFiles(uploaderState.uploadedFiles, prev),\n    [uploaderState.uploadedFiles]\n  );\n\n  const [leftFilelistOpen, setLeftFilelistOpen] = useState(false);\n  const [rightFilelistOpen, setRightFilelistOpen] = useState(false);\n\n  const [selectedLeft, setSelectedLeft] = useState<string | undefined>();\n  const [selectedRight, setSelectedRight] = useState<string | undefined>();\n  const selectFile = useCallback(\n    (name: string) => {\n      setLeftFilelistOpen(false);\n      setSelectedLeft(name);\n    },\n    [setLeftFilelistOpen, setSelectedLeft]\n  );\n  const [selectSegmentLeft, setSelectSegmentLeft] = useState<\n    [number, number] | undefined\n  >();\n  const [highlightRight, setHighlightRight] = useState<\n    [number, number] | undefined\n  >();\n  const selectRightFile = useCallback(\n    (name: string, highlight?: [[number, number], [number, number]]) => {\n      setRightFilelistOpen(false);\n      setSelectedRight(name);\n      setSelectSegmentLeft(highlight ? highlight[0] : undefined);\n      setHighlightRight(highlight ? highlight[1] : undefined);\n    },\n    [setRightFilelistOpen, setSelectedRight]\n  );\n  const selectedLeftFile =\n    selectedLeft !== undefined\n      ? uploaderState.uploadedFiles.get(selectedLeft)\n      : undefined;\n  const selectedLeftParsed =\n    selectedLeft !== undefined\n      ? parseResult.files.get(selectedLeft)\n      : undefined;\n  const selectedRightFile =\n    selectedRight !== undefined\n      ? parseResult.sourceFiles.get(selectedRight)\n      : undefined;\n  // TODO: relative path\n  const mappings = selectedLeftParsed?.sourceMapRef\n    ? parseResult.files.get(selectedLeftParsed.sourceMapRef)?.sourceMap\n        ?.mappings\n    : undefined;\n  const inversedMappings = useMemo<Segment[][] | undefined>(() => {\n    if (selectedLeft && selectedRight && mappings) {\n      return inverseMappings(selectedLeft, selectedRight, mappings);\n    } else {\n      return undefined;\n    }\n  }, [selectedLeft, selectedRight, mappings]);\n  return (\n    <div className=\"App\">\n      <h1>SourceMap Explorer</h1>\n      <div className=\"editor\">\n        <div className=\"editor-generated\">\n          <ul\n            className={\n              selectedLeftFile && !leftFilelistOpen\n                ? \"file-list closed\"\n                : \"file-list\"\n            }\n          >\n            {Array.from(uploaderState.userFiles.entries()).map(\n              ([name, file]) => (\n                <FileListEntry\n                  key={name}\n                  name={name}\n                  file={file}\n                  selected={name === selectedLeft}\n                  selectFile={selectFile}\n                  removeFile={uploaderState.removeFile}\n                />\n              )\n            )}\n            <FileListAddButton onDrop={uploaderState.onDrop} />\n          </ul>\n          {selectedLeftFile ? (\n            <>\n              <div\n                className=\"file-heading\"\n                onClick={() => setLeftFilelistOpen(true)}\n              >\n                <div className=\"file-heading-inner\">{selectedLeft}</div>\n                <button onClick={() => setLeftFilelistOpen(true)}>\n                  <FontAwesomeIcon icon={faChevronDown} />\n                </button>\n              </div>\n              <SourceMappedText\n                text={new TextDecoder().decode(selectedLeftFile.content)}\n                mappings={mappings}\n                openRight={selectRightFile}\n                highlight={selectSegmentLeft}\n              />\n            </>\n          ) : null}\n        </div>\n        <div className=\"editor-source\">\n          <ul\n            className={\n              selectedRightFile &&\n              selectedRightFile.state !== \"missing\" &&\n              !rightFilelistOpen\n                ? \"file-list closed\"\n                : \"file-list\"\n            }\n          >\n            {Array.from(parseResult.sourceFiles.entries()).map(\n              ([name, file]) => (\n                <FileListEntry\n                  key={name}\n                  name={name}\n                  file={file}\n                  selected={false}\n                  selectFile={selectRightFile}\n                  removeFile={uploaderState.removeFile}\n                />\n              )\n            )}\n          </ul>\n          {selectedRightFile && selectedRightFile.state !== \"missing\" ? (\n            <>\n              <div\n                className=\"file-heading\"\n                onClick={() => setRightFilelistOpen(true)}\n              >\n                <div className=\"file-heading-inner\">{selectedRight}</div>\n                <button onClick={() => setRightFilelistOpen(true)}>\n                  <FontAwesomeIcon icon={faChevronDown} />\n                </button>\n              </div>\n              <SourceMappedText\n                text={new TextDecoder().decode(selectedRightFile.content)}\n                mappings={inversedMappings}\n                highlight={highlightRight}\n              />\n            </>\n          ) : null}\n        </div>\n      </div>\n    </div>\n  );\n};\n\ninterface FileListEntryProps {\n  name: string;\n  file: UserFileState | SourceFileState;\n  selected: boolean;\n  removeFile: (name: string) => void;\n  selectFile?: (name: string) => void;\n}\n\nconst FileListEntry: React.FC<FileListEntryProps> = (props) => {\n  const { name, file, selected, removeFile, selectFile } = props;\n  const removeThisFile = useCallback(() => removeFile(name), [\n    name,\n    removeFile,\n  ]);\n  const selectThisFile = useCallback(() => selectFile && selectFile(name), [\n    name,\n    selectFile,\n  ]);\n  const classNames = [\n    \"file-list-entry\",\n    selected ? \"selected\" : undefined,\n  ].filter(Boolean);\n  return (\n    <li className={classNames.join(\" \")} onClick={selectThisFile}>\n      <div className=\"file-list-entry-inner\">\n        {name}\n        {file.state === \"uploading\" ? \"...\" : \"\"}\n      </div>\n      {file.state === \"uploading\" || file.state === \"uploaded\" ? (\n        <>\n          <button className=\"file-list-select\" onClick={selectThisFile}>\n            <FontAwesomeIcon icon={faCheck} />\n          </button>\n          <button className=\"file-list-remove\" onClick={removeThisFile}>\n            <FontAwesomeIcon icon={faTrash} />\n          </button>\n        </>\n      ) : null}\n    </li>\n  );\n};\n\ninterface FileListAddButtonProps {\n  onDrop: (uploadedFiles: File[]) => void;\n}\n\nconst FileListAddButton: React.FC<FileListAddButtonProps> = (props) => {\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\n    onDrop: props.onDrop,\n  });\n  return (\n    <li className=\"file-list-add-button\" {...getRootProps()}>\n      <input {...getInputProps()} />\n      {isDragActive ? (\n        <div>Drop the files here ...</div>\n      ) : (\n        <span>Drag 'n' drop some files here, or click to select files</span>\n      )}\n    </li>\n  );\n};\n\ninterface SourceMappedTextProps {\n  text: string;\n  mappings?: Segment[][];\n  highlight?: [number, number];\n  openRight?: (\n    name: string,\n    highlight?: [[number, number], [number, number]]\n  ) => void;\n}\n\nconst SourceMappedText: React.FC<SourceMappedTextProps> = (props) => {\n  const mappings = props.mappings ?? [];\n  return (\n    <pre className=\"generated-file-content\">\n      <code>\n        {props.text.split(\"\\n\").map((line, lineno) => (\n          <SourceMappedLine\n            key={lineno}\n            lineno={lineno}\n            line={line}\n            mappings={mappings[lineno]}\n            highlight={\n              props.highlight\n                ? props.highlight[0] === lineno\n                  ? props.highlight[1]\n                  : undefined\n                : undefined\n            }\n            openRight={props.openRight}\n          />\n        ))}\n      </code>\n    </pre>\n  );\n};\n\ninterface SourceMappedLineProps {\n  lineno: number;\n  line: string;\n  mappings?: Segment[];\n  highlight?: number;\n  openRight?: (\n    name: string,\n    highlight?: [[number, number], [number, number]]\n  ) => void;\n}\n\nconst SourceMappedLine: React.FC<SourceMappedLineProps> = (props) => {\n  let mappings = props.mappings ?? [];\n  if (mappings.length === 0 || mappings[0].column > 0) {\n    mappings = [{ column: 0 }].concat(mappings);\n  }\n  return (\n    <>\n      {mappings.map((mapping, i) => {\n        const nextColumn = mappings[i + 1]?.column ?? props.line.length;\n        if (mapping.column >= nextColumn) return null;\n        const segmentText = props.line.substring(mapping.column, nextColumn);\n        return (\n          <SourceMappedSegment\n            key={mapping.column}\n            lineno={props.lineno}\n            segmentText={segmentText}\n            mapping={mapping}\n            highlight={props.highlight === mapping.column}\n            openRight={props.openRight}\n          />\n        );\n      })}\n      {\"\\n\"}\n    </>\n  );\n};\n\ninterface SourceMappedSegmentProps {\n  lineno: number;\n  segmentText: string;\n  mapping: Segment;\n  highlight: boolean;\n  openRight?: (\n    name: string,\n    highlight?: [[number, number], [number, number]]\n  ) => void;\n}\n\nconst SourceMappedSegment: React.FC<SourceMappedSegmentProps> = (props) => {\n  const { segmentText, mapping, highlight, openRight } = props;\n  const openThisRight = useCallback(() => {\n    if (openRight && mapping.source) {\n      openRight(mapping.source, [\n        [props.lineno, mapping.column],\n        [mapping.sourceLine, mapping.sourceColumn],\n      ]);\n    }\n  }, [\n    openRight,\n    mapping.source,\n    props.lineno,\n    mapping.column,\n    mapping.sourceLine,\n    mapping.sourceColumn,\n  ]);\n  if (mapping.source) {\n    return (\n      <span\n        className={highlight ? \"segment-mapped highlight\" : \"segment-mapped\"}\n        onClick={openThisRight}\n      >\n        {segmentText}\n      </span>\n    );\n  } else {\n    return <span className=\"segment-unmapped\">{segmentText}</span>;\n  }\n};\n\nconst inverseMappings = (\n  name: string,\n  sourceName: string,\n  mappings: Segment[][]\n): Segment[][] => {\n  const newMappings: MappedSegment[][] = [];\n  for (const [lineno, line] of Array.from(mappings.entries())) {\n    for (const segment of line) {\n      if (!segment.source) continue;\n      if (segment.source !== sourceName) continue;\n      while (newMappings.length <= segment.sourceLine) newMappings.push([]);\n      newMappings[segment.sourceLine].push({\n        column: segment.sourceColumn,\n        source: name,\n        sourceLine: lineno,\n        sourceColumn: segment.column,\n      });\n    }\n  }\n  for (const line of newMappings) {\n    line.sort((a, b) => {\n      if (a.column !== b.column) return a.column - b.column;\n      // For sort reproducibility\n      if (a.sourceLine !== b.sourceLine) return a.sourceLine - b.sourceLine;\n      return a.sourceLine - b.sourceLine;\n    });\n  }\n  return newMappings;\n};\n\nexport default App;\n","import { useCallback, useState } from \"react\";\nimport { produce } from \"immer\";\nimport { UploadedFileState, UserFileState } from \"./file_states\";\n\nexport interface UploaderState {\n  userFiles: Map<string, UserFileState>;\n  uploadedFiles: Map<string, UploadedFileState>;\n  removeFile: (name: string) => void;\n  onDrop: (acceptedFiles: File[]) => void;\n}\n\nexport const useUploader = (): UploaderState => {\n  const [userFiles, setUserFiles] = useState<Map<string, UserFileState>>(\n    () => new Map()\n  );\n  const removeFile = useCallback(\n    (name: string) => {\n      setUserFiles((state) =>\n        produce(state, (state) => {\n          state.delete(name);\n        })\n      );\n    },\n    [setUserFiles]\n  );\n  const onDrop = useCallback(\n    (acceptedFiles: File[]) => {\n      setUserFiles((state) =>\n        produce(state, (state) => {\n          for (const file of acceptedFiles) {\n            state.set(file.name, {\n              state: \"uploading\",\n              file,\n              content: state.get(file.name)?.content,\n            });\n          }\n        })\n      );\n      for (const file of acceptedFiles) {\n        (async (file) => {\n          const content = await file.arrayBuffer();\n          setUserFiles((state) =>\n            produce(state, (state) => {\n              const oldFileState = state.get(file.name);\n              if (\n                !oldFileState ||\n                oldFileState.state !== \"uploading\" ||\n                oldFileState.file !== file\n              ) {\n                return;\n              }\n              state.set(file.name, {\n                state: \"uploaded\",\n                content,\n              });\n            })\n          );\n        })(file);\n      }\n    },\n    [setUserFiles]\n  );\n\n  const uploadedFiles: Map<string, UploadedFileState> = new Map();\n  for (const [name, file] of Array.from(userFiles.entries())) {\n    if (file.content) {\n      uploadedFiles.set(name, {\n        state: \"uploaded\",\n        content: file.content,\n      });\n    }\n  }\n\n  return {\n    uploadedFiles,\n    userFiles,\n    removeFile,\n    onDrop,\n  };\n};\n","import { ReportHandler } from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { enableMapSet } from \"immer\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nenableMapSet();\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}