{"version":3,"sources":["parse.ts","diff_memo.ts","App.tsx","uploader.ts","reportWebVitals.ts","index.tsx"],"names":["initResult","files","Map","sourceFiles","parseFile","name","content","match","sourceMap","parseSourceMap","sourceMapRef","contentText","TextDecoder","decode","matchJS","matchCSS","json","JSON","parse","Array","isArray","Error","version","file","sourceRoot","sources","sourcesContent","names","mappings","isArrayOf","isString","isStringOrNull","parseMappings","x","arr","pred","equalFiles","files1","files2","from","keys","concat","get","mappings_","lines","segments","lastColumn","lastSourceIndex","lastSourceLine","lastSourceColumn","lastNameIndex","currentSegment","current","currentBits","i","length","charCode","charCodeAt","b","base64val","push","columnDiff","toSigned","column","source","sourceLine","sourceColumn","undefined","n","equalDeps","deps1","deps2","FileListEntry","props","selected","removeFile","selectFile","removeThisFile","useCallback","selectThisFile","classNames","filter","Boolean","className","join","onClick","state","icon","faCheck","faTrash","FileListAddButton","useDropzone","onDrop","getRootProps","getInputProps","isDragActive","SourceMappedText","text","split","map","line","lineno","highlight","openRight","SourceMappedLine","mapping","nextColumn","segmentText","substring","SourceMappedSegment","openThisRight","inverseMappings","sourceName","newMappings","entries","segment","sort","a","App","uploaderState","useState","userFiles","setUserFiles","produce","delete","acceptedFiles","set","arrayBuffer","oldFileState","uploadedFiles","useUploader","parseResult","f","deps","useRef","value","useDebugValue","useDiffMemo","prev","uploadedFile","prevFile","values","sourceContent","TextEncoder","encode","has","parseFiles","leftFilelistOpen","setLeftFilelistOpen","rightFilelistOpen","setRightFilelistOpen","selectedGenerated","setSelectedGenerated","selectedRight","setSelectedRight","selectSegmentLeft","setSelectSegmentLeft","highlightRight","setHighlightRight","selectRightFile","selectedGeneratedFile","selectedGeneratedParsed","selectedRightFile","inversedMappings","useMemo","faChevronDown","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","enableMapSet","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.dc80b6c7.chunk.js","sourcesContent":["import { SourceFileState, UploadedFileState } from './file_states';\n\nexport interface ParseResult {\n  files: Map<string, ParsedFile>;\n  sourceFiles: Map<string, SourceFileState>;\n}\n\nconst initResult = (): ParseResult => ({\n  files: new Map(),\n  sourceFiles: new Map(),\n});\n\nexport interface ParsedFile {\n  content: ArrayBuffer;\n  sourceMap?: SourceMapContent;\n  sourceMapRef?: string;\n}\n\nexport interface SourceMapContent {\n  version: 3;\n  file?: string;\n  sourceRoot?: string;\n  sources: string[];\n  sourcesContent?: (string | null)[];\n  mappings: Segment[][];\n}\n\nexport interface UnmappedSegment {\n  column: number;\n  source?: undefined;\n  sourceLine?: undefined;\n  sourceColumn?: undefined;\n  name?: undefined;\n}\nexport interface MappedSegment {\n  column: number;\n  source: string;\n  sourceLine: number;\n  sourceColumn: number;\n  name?: string;\n}\nexport type Segment = UnmappedSegment | MappedSegment;\n\nexport const parseFiles = (uploadedFiles: Map<string, UploadedFileState>, prev: ParseResult = initResult()): ParseResult => {\n  const files = new Map<string, ParsedFile>();\n  for (const [name, uploadedFile] of Array.from(uploadedFiles.entries())) {\n    const prevFile = prev.files.get(name);\n    if (prevFile && prevFile.content === uploadedFile.content) {\n      files.set(name, prevFile);\n    } else {\n      files.set(name, parseFile(name, uploadedFile.content));\n    }\n  }\n\n  // Return prev if nothing has been changed.\n  if (equalFiles(prev.files, files)) {\n    return prev;\n  }\n\n  const sourceFiles = new Map<string, SourceFileState>();\n  for (const file of Array.from(files.values())) {\n    if (file.sourceMap) {\n      for (const source of file.sourceMap.sources) {\n        // TODO: sourceRoot\n        sourceFiles.set(source, { state: \"missing\" });\n      }\n    }\n  }\n  for (const file of Array.from(files.values())) {\n    if (file.sourceMap && file.sourceMap.sourcesContent) {\n      for (const [i, source] of Array.from(file.sourceMap.sources.entries())) {\n        // TODO: sourceRoot\n        const sourceContent = file.sourceMap.sourcesContent[i];\n        if (sourceContent) {\n          sourceFiles.set(source, { state: \"bundled\", content: new TextEncoder().encode(sourceContent) });\n        }\n      }\n    }\n  }\n  for (const [name, uploadedFile] of Array.from(uploadedFiles.entries())) {\n    if (sourceFiles.has(name)) {\n      sourceFiles.set(name, { state: \"uploaded\", content: uploadedFile.content });\n    }\n  }\n  return {\n    files,\n    sourceFiles,\n  };\n};\n\nconst parseFile = (name: string, content: ArrayBuffer): ParsedFile => {\n  if (name.match(/\\.map$/)) {\n    return {\n      content,\n      sourceMap: parseSourceMap(content),\n    };\n  }\n  let sourceMapRef: string | undefined;\n  const contentText = new TextDecoder().decode(content);\n  const matchJS = contentText.match(/^\\/\\/# sourceMappingURL=(.*)$/m);\n  const matchCSS = contentText.match(/^\\/\\*# sourceMappingURL=(.*) \\*\\/$/m);\n  if (matchJS) {\n    sourceMapRef = matchJS[1];\n  } else if (matchCSS) {\n    sourceMapRef = matchCSS[1];\n  }\n  return { content, sourceMapRef };\n};\n\nconst parseSourceMap = (content: ArrayBuffer): SourceMapContent => {\n  const json: unknown = JSON.parse(new TextDecoder().decode(content));\n  if (typeof json !== \"object\" || json === null || Array.isArray(json)) {\n    throw new Error(\"SourecMap should be an object\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const _typecheck_json: object = json;\n  const { version, file, sourceRoot, sources, sourcesContent, names, mappings } = json as { [key in string]?: unknown };\n  if (version !== 3) {\n    throw new Error(\"Invalid version\");\n  }\n  if (typeof file !== \"undefined\" && typeof file !== \"string\") {\n    throw new Error(\"file must be a string\");\n  }\n  if (typeof sourceRoot !== \"undefined\" && typeof sourceRoot !== \"string\") {\n    throw new Error(\"sourceRoot must be a string\");\n  }\n  if (!isArrayOf(sources, isString)) {\n    throw new Error(\"sources must be an array of strings\")\n  }\n  if (typeof sourcesContent !== \"undefined\" && !isArrayOf(sourcesContent, isStringOrNull)) {\n    throw new Error(\"sourcesContent must be an array of strings or nulls\")\n  }\n  if (!isArrayOf(names, isString)) {\n    throw new Error(\"names must be an array of strings\")\n  }\n  if (typeof mappings !== \"string\") {\n    throw new Error(\"mappings must be a string\");\n  }\n  return {\n    version,\n    file,\n    sourceRoot,\n    sources,\n    sourcesContent,\n    mappings: parseMappings(mappings, sources, names),\n  };\n};\n\nconst isString = (x: unknown): x is string => typeof x === \"string\";\nconst isStringOrNull = (x: unknown): x is (string | null) => typeof x === \"string\" || x === null;\n\nconst isArrayOf = <T>(arr: unknown, pred: (x: unknown) => x is T): arr is T[] => {\n  if (!Array.isArray(arr)) {\n    return false;\n  }\n  for (const elem of arr) {\n    if (!pred(elem)) return false;\n  }\n  return true;\n}\n\nconst equalFiles = (files1: Map<string, ParsedFile>, files2: Map<string, ParsedFile>): boolean => {\n  for (const name of Array.from(files1.keys()).concat(Array.from(files2.keys()))) {\n    if (files1.get(name) !== files2.get(name)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst parseMappings = (mappings_: string, sources: string[], names: string[]): Segment[][] => {\n  const mappings = mappings_ + \";\";\n  const lines: Segment[][] = [];\n  let segments: Segment[] = [];\n  let lastColumn = 0;\n  let lastSourceIndex = 0;\n  let lastSourceLine = 0;\n  let lastSourceColumn = 0;\n  let lastNameIndex = 0;\n  let currentSegment: number[] = [];\n  let current = 0;\n  let currentBits = 0;\n  for (let i = 0; i < mappings.length; i++) {\n    const charCode = mappings.charCodeAt(i);\n    if (charCode === 0x3B /* ; */ || charCode === 0x2C /* , */) {\n      if (current !== 0 || currentBits !== 0) throw new Error(\"VLQ runover\");\n      if (currentSegment.length === 0 && charCode === 0x3B /* ; */) {\n        lines.push(segments);\n        segments = [];\n        lastColumn = 0;\n        continue;\n      }\n      if (currentSegment.length === 0) throw new Error(\"Segment too short\");\n      const columnDiff = toSigned(currentSegment[0]);\n      if (columnDiff < 0) throw new Error(\"column must be monotonic\");\n      lastColumn += columnDiff;\n      if (currentSegment.length === 4 || currentSegment.length === 5) {\n        const sourceIndexDiff = toSigned(currentSegment[1]);\n        const sourceLineDiff = toSigned(currentSegment[2]);\n        const sourceColumnDiff = toSigned(currentSegment[3]);\n        lastSourceIndex += sourceIndexDiff;\n        lastSourceLine += sourceLineDiff;\n        lastSourceColumn += sourceColumnDiff;\n        if (currentSegment.length === 5) {\n          lastNameIndex += toSigned(currentSegment[4]);\n        }\n      } else if (currentSegment.length !== 1) {\n        throw new Error(\"Invalid segment length\");\n      }\n      segments.push({\n        column: lastColumn,\n        // TODO: check index\n        source: sources[lastSourceIndex],\n        sourceLine: lastSourceLine,\n        sourceColumn: lastSourceColumn,\n        name: currentSegment.length === 5 ? names[lastNameIndex] : undefined,\n      });\n      currentSegment = [];\n      if (charCode === 0x3B /* ; */) {\n        lines.push(segments);\n        segments = [];\n        lastColumn = 0;\n      }\n      continue;\n    }\n    const b = base64val(charCode);\n    if (b < 32) {\n      currentSegment.push(current | (b << currentBits));\n      current = 0;\n      currentBits = 0;\n    } else {\n      current |= ((b & 31) << currentBits);\n      currentBits += 5;\n    }\n  }\n  return lines;\n}\n\nconst base64val = (charCode: number): number => {\n  if (charCode >= 0x41 /* A */ && charCode <= 0x5A /* Z */) {\n    return charCode - 0x41;\n  } else if (charCode >= 0x61 /* a */ && charCode <= 0x7A /* z */) {\n    return charCode - (0x61 - 26);\n  } else if (charCode >= 0x30 /* 0 */ && charCode <= 0x39 /* 9 */) {\n    return charCode + (52 - 0x30);\n  } else if (charCode === 0x2B /* + */) {\n    return 62;\n  } else if (charCode === 0x2F /* / */) {\n    return 63;\n  } else {\n    throw new Error(`Invalid base64 value: ${charCode}`);\n  }\n};\n\nconst toSigned = (n: number): number => {\n  if (n & 1) {\n    return -(n >> 1);\n  } else {\n    return (n >> 1);\n  }\n}\n","import { useDebugValue, useRef } from \"react\";\n\ninterface DiffMemoState<T> {\n  deps: any[];\n  value: T;\n}\n\nexport const useDiffMemo = <T>(f: (prev?: T) => T, deps: any[]): T => {\n  const state = useRef<DiffMemoState<T> | null>(null);\n  if (state.current === null) {\n    const value = f();\n    state.current = { deps, value };\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue(value);\n    return value;\n  } else if (!equalDeps(state.current.deps, deps)) {\n    const value = f(state.current.value);\n    state.current = { deps, value };\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue(value);\n    return value;\n  } else {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue(state.current.value);\n    return state.current.value;\n  }\n};\n\nconst equalDeps = (deps1: any[], deps2: any[]): boolean => {\n  if (deps1.length !== deps2.length) return false;\n  for (let i = 0; i < deps1.length; i++) {\n    if (deps1[i] !== deps2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n","import React, { useCallback, useMemo, useState } from 'react';\nimport { useDropzone } from 'react-dropzone';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faTrash, faChevronDown, faCheck } from '@fortawesome/free-solid-svg-icons';\nimport { SourceFileState, UserFileState } from './file_states';\nimport { useUploader } from './uploader';\nimport './App.css';\nimport { MappedSegment, parseFiles, ParseResult, Segment } from './parse';\nimport { useDiffMemo } from './diff_memo';\n\nconst App: React.FC = () => {\n  const uploaderState = useUploader();\n  const parseResult = useDiffMemo((prev?: ParseResult) => parseFiles(uploaderState.uploadedFiles, prev), [uploaderState.uploadedFiles]);\n\n  const [leftFilelistOpen, setLeftFilelistOpen] = useState(false);\n  const [rightFilelistOpen, setRightFilelistOpen] = useState(false);\n\n  const [selectedGenerated, setSelectedGenerated] = useState<string | undefined>(undefined);\n  const [selectedRight, setSelectedRight] = useState<string | undefined>(undefined);\n  const selectFile = useCallback((name: string) => {\n    setLeftFilelistOpen(false);\n    setSelectedGenerated(name);\n  }, [setLeftFilelistOpen, setSelectedGenerated]);\n  const [selectSegmentLeft, setSelectSegmentLeft] = useState<[number, number] | undefined>();\n  const [highlightRight, setHighlightRight] = useState<[number, number] | undefined>();\n  const selectRightFile = useCallback((name: string, highlight?: [[number, number], [number, number]]) => {\n    setRightFilelistOpen(false);\n    setSelectedRight(name);\n    setSelectSegmentLeft(highlight ? highlight[0] : undefined);\n    setHighlightRight(highlight ? highlight[1] : undefined);\n  }, [setRightFilelistOpen, setSelectedRight]);\n  const selectedGeneratedFile = selectedGenerated !== undefined ? uploaderState.uploadedFiles.get(selectedGenerated) : undefined;\n  const selectedGeneratedParsed = selectedGenerated !== undefined ? parseResult.files.get(selectedGenerated) : undefined;\n  const selectedRightFile = selectedRight !== undefined ? parseResult.sourceFiles.get(selectedRight) : undefined;\n  // TODO: relative path\n  const mappings =\n    selectedGeneratedParsed?.sourceMapRef ?\n    parseResult.files.get(selectedGeneratedParsed.sourceMapRef)?.sourceMap?.mappings :\n    undefined;\n  const inversedMappings = useMemo<Segment[][] | undefined>(() => {\n    if (selectedGenerated && selectedRight && mappings) {\n      return inverseMappings(selectedGenerated, selectedRight, mappings);\n    } else {\n      return undefined;\n    }\n  }, [selectedGenerated, selectedRight, mappings]);\n  return (\n    <div className=\"App\">\n      <h1>SourceMap Explorer</h1>\n      <div className=\"editor\">\n        <div className=\"editor-generated\">\n          <ul className={(selectedGeneratedFile && !leftFilelistOpen) ? \"file-list closed\" : \"file-list\"}>\n            {\n              Array.from(uploaderState.userFiles.entries()).map(([name, file]) => (\n                <FileListEntry key={name} name={name} file={file} selected={name === selectedGenerated} selectFile={selectFile} removeFile={uploaderState.removeFile} />\n              ))\n            }\n            <FileListAddButton onDrop={uploaderState.onDrop} />\n          </ul>\n          {selectedGeneratedFile ?\n            <>\n              <div className=\"file-heading\" onClick={() => setLeftFilelistOpen(true)}>\n                <div className=\"file-heading-inner\">{selectedGenerated}</div>\n                <button onClick={() => setLeftFilelistOpen(true)}>\n                  <FontAwesomeIcon icon={faChevronDown} />\n                </button>\n              </div>\n              <SourceMappedText text={new TextDecoder().decode(selectedGeneratedFile.content)} mappings={mappings} openRight={selectRightFile} highlight={selectSegmentLeft} />\n            </>\n            : null\n          }\n        </div>\n        <div className=\"editor-source\">\n          <ul className={(selectedRightFile && selectedRightFile.state !== \"missing\" && !rightFilelistOpen) ? \"file-list closed\" : \"file-list\"}>\n            {\n              Array.from(parseResult.sourceFiles.entries()).map(([name, file]) => (\n                <FileListEntry key={name} name={name} file={file} selected={false} selectFile={selectRightFile} removeFile={uploaderState.removeFile} />\n              ))\n            }\n          </ul>\n          {(selectedRightFile && selectedRightFile.state !== \"missing\") ?\n            <>\n              <div className=\"file-heading\" onClick={() => setRightFilelistOpen(true)}>\n                <div className=\"file-heading-inner\">{selectedRight}</div>\n                <button onClick={() => setRightFilelistOpen(true)}>\n                  <FontAwesomeIcon icon={faChevronDown} />\n                </button>\n              </div>\n              <SourceMappedText text={new TextDecoder().decode(selectedRightFile.content)} mappings={inversedMappings} highlight={highlightRight} />\n            </>\n            : null\n          }\n        </div>\n      </div>\n    </div>\n  );\n};\n\ninterface FileListEntryProps {\n  name: string;\n  file: UserFileState | SourceFileState;\n  selected: boolean;\n  removeFile: (name: string) => void;\n  selectFile?: (name: string) => void;\n}\n\nconst FileListEntry: React.FC<FileListEntryProps> = (props) => {\n  const { name, file, selected, removeFile, selectFile } = props;\n  const removeThisFile = useCallback(() => removeFile(name), [name, removeFile]);\n  const selectThisFile = useCallback(() => selectFile && selectFile(name), [name, selectFile]);\n  const classNames = [\"file-list-entry\", selected ? \"selected\" : undefined].filter(Boolean);\n  return (\n    <li className={classNames.join(\" \")} onClick={selectThisFile}>\n      <div className=\"file-list-entry-inner\">\n        {name}{file.state === \"uploading\" ? \"...\" : \"\"}\n      </div>\n      {\n        file.state === \"uploading\" || file.state === \"uploaded\" ?\n        <>\n          <button className=\"file-list-select\" onClick={selectThisFile}>\n            <FontAwesomeIcon icon={faCheck} />\n          </button>\n          <button className=\"file-list-remove\" onClick={removeThisFile}>\n            <FontAwesomeIcon icon={faTrash} />\n          </button>\n        </> :\n        null\n      }\n    </li>\n  );\n};\n\ninterface FileListAddButtonProps {\n  onDrop: (uploadedFiles: File[]) => void;\n}\n\nconst FileListAddButton: React.FC<FileListAddButtonProps> = (props) => {\n  const {getRootProps, getInputProps, isDragActive} = useDropzone({onDrop: props.onDrop})\n  return (\n    <li className=\"file-list-add-button\" {...getRootProps()}>\n      <input {...getInputProps()} />\n      {\n        isDragActive ?\n          <div>Drop the files here ...</div> :\n          <span>Drag 'n' drop some files here, or click to select files</span>\n      }\n    </li>\n  );\n};\n\ninterface SourceMappedTextProps {\n  text: string;\n  mappings?: Segment[][];\n  highlight?: [number, number];\n  openRight?: (name: string, highlight?: [[number, number], [number, number]]) => void;\n}\n\nconst SourceMappedText: React.FC<SourceMappedTextProps> = (props) => {\n  const mappings = props.mappings ?? [];\n  return (\n    <pre className=\"generated-file-content\">\n      <code>\n        {\n          props.text.split(\"\\n\").map((line, lineno) => (\n            <SourceMappedLine\n              key={lineno}\n              lineno={lineno}\n              line={line}\n              mappings={mappings[lineno]}\n              highlight={\n                props.highlight ? props.highlight[0] === lineno ? props.highlight[1] : undefined : undefined\n              }\n              openRight={props.openRight}\n            />\n          ))\n        }\n      </code>\n    </pre>\n  );\n};\n\ninterface SourceMappedLineProps {\n  lineno: number;\n  line: string;\n  mappings?: Segment[];\n  highlight?: number;\n  openRight?: (name: string, highlight?: [[number, number], [number, number]]) => void;\n}\n\nconst SourceMappedLine: React.FC<SourceMappedLineProps> = (props) => {\n  let mappings = props.mappings ?? [];\n  if (mappings.length === 0 || mappings[0].column > 0) {\n    mappings = [{ column: 0 }].concat(mappings);\n  }\n  return (\n    <>\n      {\n        mappings.map((mapping, i) => {\n          const nextColumn = mappings[i + 1]?.column ?? props.line.length;\n          if (mapping.column >= nextColumn) return null;\n          const segmentText = props.line.substring(mapping.column, nextColumn);\n          return <SourceMappedSegment\n            key={mapping.column}\n            lineno={props.lineno}\n            segmentText={segmentText}\n            mapping={mapping}\n            highlight={props.highlight === mapping.column}\n            openRight={props.openRight}\n          />\n        })\n      }\n      {\"\\n\"}\n    </>\n  );\n};\n\ninterface SourceMappedSegmentProps {\n  lineno: number;\n  segmentText: string;\n  mapping: Segment;\n  highlight: boolean;\n  openRight?: (name: string, highlight?: [[number, number], [number, number]]) => void;\n}\n\nconst SourceMappedSegment: React.FC<SourceMappedSegmentProps> = (props) => {\n  const { segmentText, mapping, highlight, openRight } = props;\n  const openThisRight = useCallback(() => {\n    if (openRight && mapping.source) {\n      openRight(mapping.source, [\n        [props.lineno, mapping.column],\n        [mapping.sourceLine, mapping.sourceColumn],\n      ]);\n    }\n  }, [openRight, mapping.source, props.lineno, mapping.column, mapping.sourceLine, mapping.sourceColumn]);\n  if (mapping.source) {\n    return <span className={highlight ? \"segment-mapped highlight\" : \"segment-mapped\"} onClick={openThisRight}>{segmentText}</span>;\n  } else {\n    return <span className=\"segment-unmapped\">{segmentText}</span>;\n  }\n};\n\nconst inverseMappings = (name: string, sourceName: string, mappings: Segment[][]): Segment[][] => {\n  const newMappings: MappedSegment[][] = [];\n  for (const [lineno, line] of Array.from(mappings.entries())) {\n    for (const segment of line) {\n      if (!segment.source) continue;\n      if (segment.source !== sourceName) continue;\n      while (newMappings.length <= segment.sourceLine) newMappings.push([]);\n      newMappings[segment.sourceLine].push({\n        column: segment.sourceColumn,\n        source: name,\n        sourceLine: lineno,\n        sourceColumn: segment.column,\n      });\n    }\n  }\n  for (const line of newMappings) {\n    line.sort((a, b) => {\n      if (a.column !== b.column) return a.column - b.column;\n      // For sort reproducibility\n      if (a.sourceLine !== b.sourceLine) return a.sourceLine - b.sourceLine;\n      return a.sourceLine - b.sourceLine;\n    });\n  }\n  return newMappings;\n};\n\nexport default App;\n","import { useCallback, useState } from 'react';\nimport { produce } from 'immer';\nimport { UploadedFileState, UserFileState } from './file_states';\n\nexport interface UploaderState {\n  userFiles: Map<string, UserFileState>;\n  uploadedFiles: Map<string, UploadedFileState>;\n  removeFile: (name: string) => void;\n  onDrop: (acceptedFiles: File[]) => void;\n}\n\nexport const useUploader = (): UploaderState => {\n  const [userFiles, setUserFiles] = useState<Map<string, UserFileState>>(() => new Map());\n  const removeFile = useCallback((name: string) => {\n    setUserFiles((state) => produce(state, (state) => {\n      state.delete(name);\n    }));\n  }, [setUserFiles]);\n  const onDrop = useCallback((acceptedFiles: File[]) => {\n    setUserFiles((state) => produce(state, (state) => {\n      for (const file of acceptedFiles) {\n        state.set(file.name, {\n          state: \"uploading\",\n          file,\n          content: state.get(file.name)?.content,\n        });\n      }\n    }));\n    for (const file of acceptedFiles) {\n      (async (file) => {\n        const content = await file.arrayBuffer();\n        setUserFiles((state) => produce(state, (state) => {\n          const oldFileState = state.get(file.name);\n          if (!oldFileState || oldFileState.state !== \"uploading\" || oldFileState.file !== file) {\n            return;\n          }\n          state.set(file.name, {\n            state: \"uploaded\",\n            content,\n          });\n        }));\n      })(file);\n    }\n  }, [setUserFiles]);\n\n  const uploadedFiles: Map<string, UploadedFileState> = new Map();\n  for (const [name, file] of Array.from(userFiles.entries())) {\n    if (file.content) {\n      uploadedFiles.set(name, {\n        state: \"uploaded\",\n        content: file.content,\n      })\n    }\n  }\n\n  return {\n    uploadedFiles,\n    userFiles,\n    removeFile,\n    onDrop,\n  }\n};\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { enableMapSet } from 'immer';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nenableMapSet();\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}