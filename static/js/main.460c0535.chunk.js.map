{"version":3,"sources":["parse.ts","diff_memo.ts","App.tsx","uploader.ts","reportWebVitals.ts","index.tsx"],"names":["initResult","files","Map","sourceFiles","parseFile","name","content","match","sourceMap","parseSourceMap","sourceMapRef","contentText","TextDecoder","decode","matchJS","matchCSS","json","JSON","parse","Array","isArray","Error","version","file","sourceRoot","sources","sourcesContent","names","mappings","isArrayOf","isString","isStringOrNull","parseMappings","x","arr","pred","equalFiles","files1","files2","from","keys","concat","get","mappings_","lines","segments","lastColumn","lastSourceIndex","lastSourceLine","lastSourceColumn","lastNameIndex","currentSegment","current","currentBits","i","length","charCode","charCodeAt","b","base64val","push","columnDiff","toSigned","column","source","sourceLine","sourceColumn","undefined","n","equalDeps","deps1","deps2","FileListEntry","props","selected","removeFile","renameFile","selectFile","useState","nameEditing","setNameEditing","editable","state","editing","classNames","filter","Boolean","className","join","onClick","e","type","value","onChange","currentTarget","onKeyPress","key","autoFocus","stopPropagation","icon","faCaretDown","faCheck","faUndo","faEdit","faTrash","FileListAddButton","useDropzone","onDrop","getRootProps","getInputProps","isDragActive","SourceMappedText","text","split","map","line","lineno","highlight","openRight","SourceMappedLine","mapping","nextColumn","segmentText","substring","SourceMappedSegment","openThisRight","useCallback","highlightRef","useRef","useEffect","scrollIntoView","block","inline","ref","inverseMappings","sourceName","newMappings","entries","segment","sort","a","App","uploaderState","userFiles","setUserFiles","produce","delete","newName","entry","set","acceptedFiles","arrayBuffer","oldFileState","uploadedFiles","useUploader","parseResult","f","deps","useDebugValue","useDiffMemo","prev","uploadedFile","prevFile","values","sourceContent","TextEncoder","encode","has","parseFiles","leftFilelistOpen","setLeftFilelistOpen","rightFilelistOpen","setRightFilelistOpen","selectedLeft","setSelectedLeft","selectedRight","setSelectedRight","selectSegmentLeft","setSelectSegmentLeft","highlightRight","setHighlightRight","selectRightFile","selectedLeftFile","selectedLeftParsed","selectedRightFile","inversedMappings","useMemo","faChevronDown","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","enableMapSet","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.460c0535.chunk.js","sourcesContent":["import { SourceFileState, UploadedFileState } from \"./file_states\";\n\nexport interface ParseResult {\n  files: Map<string, ParsedFile>;\n  sourceFiles: Map<string, SourceFileState>;\n}\n\nconst initResult = (): ParseResult => ({\n  files: new Map(),\n  sourceFiles: new Map(),\n});\n\nexport interface ParsedFile {\n  content: ArrayBuffer;\n  sourceMap?: SourceMapContent;\n  sourceMapRef?: string;\n}\n\nexport interface SourceMapContent {\n  version: 3;\n  file?: string;\n  sourceRoot?: string;\n  sources: string[];\n  sourcesContent?: (string | null)[];\n  mappings: Segment[][];\n}\n\nexport interface UnmappedSegment {\n  column: number;\n  source?: undefined;\n  sourceLine?: undefined;\n  sourceColumn?: undefined;\n  name?: undefined;\n}\nexport interface MappedSegment {\n  column: number;\n  source: string;\n  sourceLine: number;\n  sourceColumn: number;\n  name?: string;\n}\nexport type Segment = UnmappedSegment | MappedSegment;\n\nexport const parseFiles = (\n  uploadedFiles: Map<string, UploadedFileState>,\n  prev: ParseResult = initResult()\n): ParseResult => {\n  const files = new Map<string, ParsedFile>();\n  for (const [name, uploadedFile] of Array.from(uploadedFiles.entries())) {\n    const prevFile = prev.files.get(name);\n    if (prevFile && prevFile.content === uploadedFile.content) {\n      files.set(name, prevFile);\n    } else {\n      files.set(name, parseFile(name, uploadedFile.content));\n    }\n  }\n\n  // Return prev if nothing has been changed.\n  if (equalFiles(prev.files, files)) {\n    return prev;\n  }\n\n  const sourceFiles = new Map<string, SourceFileState>();\n  for (const file of Array.from(files.values())) {\n    if (file.sourceMap) {\n      for (const source of file.sourceMap.sources) {\n        // TODO: sourceRoot\n        sourceFiles.set(source, { state: \"missing\" });\n      }\n    }\n  }\n  for (const file of Array.from(files.values())) {\n    if (file.sourceMap && file.sourceMap.sourcesContent) {\n      for (const [i, source] of Array.from(file.sourceMap.sources.entries())) {\n        // TODO: sourceRoot\n        const sourceContent = file.sourceMap.sourcesContent[i];\n        if (sourceContent) {\n          sourceFiles.set(source, {\n            state: \"bundled\",\n            content: new TextEncoder().encode(sourceContent),\n          });\n        }\n      }\n    }\n  }\n  for (const [name, uploadedFile] of Array.from(uploadedFiles.entries())) {\n    if (sourceFiles.has(name)) {\n      sourceFiles.set(name, {\n        state: \"uploaded\",\n        content: uploadedFile.content,\n      });\n    }\n  }\n  return {\n    files,\n    sourceFiles,\n  };\n};\n\nconst parseFile = (name: string, content: ArrayBuffer): ParsedFile => {\n  if (name.match(/\\.map$/)) {\n    return {\n      content,\n      sourceMap: parseSourceMap(content),\n    };\n  }\n  let sourceMapRef: string | undefined;\n  const contentText = new TextDecoder().decode(content);\n  const matchJS = contentText.match(/^\\/\\/# sourceMappingURL=(.*)$/m);\n  const matchCSS = contentText.match(/^\\/\\*# sourceMappingURL=(.*) \\*\\/$/m);\n  if (matchJS) {\n    sourceMapRef = matchJS[1];\n  } else if (matchCSS) {\n    sourceMapRef = matchCSS[1];\n  }\n  return { content, sourceMapRef };\n};\n\nconst parseSourceMap = (content: ArrayBuffer): SourceMapContent => {\n  const json: unknown = JSON.parse(new TextDecoder().decode(content));\n  if (typeof json !== \"object\" || json === null || Array.isArray(json)) {\n    throw new Error(\"SourecMap should be an object\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/ban-types\n  const _typecheck_json: object = json;\n  const {\n    version,\n    file,\n    sourceRoot,\n    sources,\n    sourcesContent,\n    names,\n    mappings,\n  } = json as { [key in string]?: unknown };\n  if (version !== 3) {\n    throw new Error(\"Invalid version\");\n  }\n  if (typeof file !== \"undefined\" && typeof file !== \"string\") {\n    throw new Error(\"file must be a string\");\n  }\n  if (typeof sourceRoot !== \"undefined\" && typeof sourceRoot !== \"string\") {\n    throw new Error(\"sourceRoot must be a string\");\n  }\n  if (!isArrayOf(sources, isString)) {\n    throw new Error(\"sources must be an array of strings\");\n  }\n  if (\n    typeof sourcesContent !== \"undefined\" &&\n    !isArrayOf(sourcesContent, isStringOrNull)\n  ) {\n    throw new Error(\"sourcesContent must be an array of strings or nulls\");\n  }\n  if (!isArrayOf(names, isString)) {\n    throw new Error(\"names must be an array of strings\");\n  }\n  if (typeof mappings !== \"string\") {\n    throw new Error(\"mappings must be a string\");\n  }\n  return {\n    version,\n    file,\n    sourceRoot,\n    sources,\n    sourcesContent,\n    mappings: parseMappings(mappings, sources, names),\n  };\n};\n\nconst isString = (x: unknown): x is string => typeof x === \"string\";\nconst isStringOrNull = (x: unknown): x is string | null =>\n  typeof x === \"string\" || x === null;\n\nconst isArrayOf = <T>(\n  arr: unknown,\n  pred: (x: unknown) => x is T\n): arr is T[] => {\n  if (!Array.isArray(arr)) {\n    return false;\n  }\n  for (const elem of arr) {\n    if (!pred(elem)) return false;\n  }\n  return true;\n};\n\nconst equalFiles = (\n  files1: Map<string, ParsedFile>,\n  files2: Map<string, ParsedFile>\n): boolean => {\n  for (const name of Array.from(files1.keys()).concat(\n    Array.from(files2.keys())\n  )) {\n    if (files1.get(name) !== files2.get(name)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst parseMappings = (\n  mappings_: string,\n  sources: string[],\n  names: string[]\n): Segment[][] => {\n  const mappings = mappings_ + \";\";\n  const lines: Segment[][] = [];\n  let segments: Segment[] = [];\n  let lastColumn = 0;\n  let lastSourceIndex = 0;\n  let lastSourceLine = 0;\n  let lastSourceColumn = 0;\n  let lastNameIndex = 0;\n  let currentSegment: number[] = [];\n  let current = 0;\n  let currentBits = 0;\n  for (let i = 0; i < mappings.length; i++) {\n    const charCode = mappings.charCodeAt(i);\n    if (charCode === 0x3b /* ; */ || charCode === 0x2c /* , */) {\n      if (current !== 0 || currentBits !== 0) throw new Error(\"VLQ runover\");\n      if (currentSegment.length === 0 && charCode === 0x3b /* ; */) {\n        lines.push(segments);\n        segments = [];\n        lastColumn = 0;\n        continue;\n      }\n      if (currentSegment.length === 0) throw new Error(\"Segment too short\");\n      const columnDiff = toSigned(currentSegment[0]);\n      if (columnDiff < 0) throw new Error(\"column must be monotonic\");\n      lastColumn += columnDiff;\n      if (currentSegment.length === 4 || currentSegment.length === 5) {\n        const sourceIndexDiff = toSigned(currentSegment[1]);\n        const sourceLineDiff = toSigned(currentSegment[2]);\n        const sourceColumnDiff = toSigned(currentSegment[3]);\n        lastSourceIndex += sourceIndexDiff;\n        lastSourceLine += sourceLineDiff;\n        lastSourceColumn += sourceColumnDiff;\n        if (currentSegment.length === 5) {\n          lastNameIndex += toSigned(currentSegment[4]);\n        }\n      } else if (currentSegment.length !== 1) {\n        throw new Error(\"Invalid segment length\");\n      }\n      segments.push({\n        column: lastColumn,\n        // TODO: check index\n        source: sources[lastSourceIndex],\n        sourceLine: lastSourceLine,\n        sourceColumn: lastSourceColumn,\n        name: currentSegment.length === 5 ? names[lastNameIndex] : undefined,\n      });\n      currentSegment = [];\n      if (charCode === 0x3b /* ; */) {\n        lines.push(segments);\n        segments = [];\n        lastColumn = 0;\n      }\n      continue;\n    }\n    const b = base64val(charCode);\n    if (b < 32) {\n      currentSegment.push(current | (b << currentBits));\n      current = 0;\n      currentBits = 0;\n    } else {\n      current |= (b & 31) << currentBits;\n      currentBits += 5;\n    }\n  }\n  return lines;\n};\n\nconst base64val = (charCode: number): number => {\n  if (charCode >= 0x41 /* A */ && charCode <= 0x5a /* Z */) {\n    return charCode - 0x41;\n  } else if (charCode >= 0x61 /* a */ && charCode <= 0x7a /* z */) {\n    return charCode - (0x61 - 26);\n  } else if (charCode >= 0x30 /* 0 */ && charCode <= 0x39 /* 9 */) {\n    return charCode + (52 - 0x30);\n  } else if (charCode === 0x2b /* + */) {\n    return 62;\n  } else if (charCode === 0x2f /* / */) {\n    return 63;\n  } else {\n    throw new Error(`Invalid base64 value: ${charCode}`);\n  }\n};\n\nconst toSigned = (n: number): number => {\n  if (n & 1) {\n    return -(n >> 1);\n  } else {\n    return n >> 1;\n  }\n};\n","import { useDebugValue, useRef } from \"react\";\n\ninterface DiffMemoState<T> {\n  deps: unknown[];\n  value: T;\n}\n\nexport const useDiffMemo = <T>(f: (prev?: T) => T, deps: unknown[]): T => {\n  const state = useRef<DiffMemoState<T> | null>(null);\n  if (state.current === null) {\n    const value = f();\n    state.current = { deps, value };\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue(value);\n    return value;\n  } else if (!equalDeps(state.current.deps, deps)) {\n    const value = f(state.current.value);\n    state.current = { deps, value };\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue(value);\n    return value;\n  } else {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDebugValue(state.current.value);\n    return state.current.value;\n  }\n};\n\nconst equalDeps = (deps1: unknown[], deps2: unknown[]): boolean => {\n  if (deps1.length !== deps2.length) return false;\n  for (let i = 0; i < deps1.length; i++) {\n    if (deps1[i] !== deps2[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n","import React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  faTrash,\n  faChevronDown,\n  faCheck,\n  faEdit,\n  faUndo,\n  faCaretDown,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { SourceFileState, UserFileState } from \"./file_states\";\nimport { useUploader } from \"./uploader\";\nimport \"./App.css\";\nimport { MappedSegment, parseFiles, ParseResult, Segment } from \"./parse\";\nimport { useDiffMemo } from \"./diff_memo\";\n\nconst App: React.FC = () => {\n  const uploaderState = useUploader();\n  const parseResult = useDiffMemo(\n    (prev?: ParseResult) => parseFiles(uploaderState.uploadedFiles, prev),\n    [uploaderState.uploadedFiles]\n  );\n\n  const [leftFilelistOpen, setLeftFilelistOpen] = useState(false);\n  const [rightFilelistOpen, setRightFilelistOpen] = useState(false);\n\n  const [selectedLeft, setSelectedLeft] = useState<string | undefined>();\n  const [selectedRight, setSelectedRight] = useState<string | undefined>();\n  const selectFile = useCallback(\n    (name: string) => {\n      setLeftFilelistOpen(false);\n      setSelectedLeft(name);\n    },\n    [setLeftFilelistOpen, setSelectedLeft]\n  );\n  const [selectSegmentLeft, setSelectSegmentLeft] = useState<\n    [number, number] | undefined\n  >();\n  const [highlightRight, setHighlightRight] = useState<\n    [number, number] | undefined\n  >();\n  const selectRightFile = useCallback(\n    (name: string, highlight?: [[number, number], [number, number]]) => {\n      setRightFilelistOpen(false);\n      setSelectedRight(name);\n      setSelectSegmentLeft(highlight ? highlight[0] : undefined);\n      setHighlightRight(highlight ? highlight[1] : undefined);\n    },\n    [setRightFilelistOpen, setSelectedRight]\n  );\n  const selectedLeftFile =\n    selectedLeft !== undefined\n      ? uploaderState.uploadedFiles.get(selectedLeft)\n      : undefined;\n  const selectedLeftParsed =\n    selectedLeft !== undefined\n      ? parseResult.files.get(selectedLeft)\n      : undefined;\n  const selectedRightFile =\n    selectedRight !== undefined\n      ? parseResult.sourceFiles.get(selectedRight)\n      : undefined;\n  // TODO: relative path\n  const mappings = selectedLeftParsed?.sourceMapRef\n    ? parseResult.files.get(selectedLeftParsed.sourceMapRef)?.sourceMap\n        ?.mappings\n    : undefined;\n  const inversedMappings = useMemo<Segment[][] | undefined>(() => {\n    if (selectedLeft && selectedRight && mappings) {\n      return inverseMappings(selectedLeft, selectedRight, mappings);\n    } else {\n      return undefined;\n    }\n  }, [selectedLeft, selectedRight, mappings]);\n  return (\n    <div className=\"App\">\n      <h1>SourceMap Explorer</h1>\n      <div className=\"editor\">\n        <div className=\"editor-generated\">\n          <ul\n            className={\n              selectedLeftFile && !leftFilelistOpen\n                ? \"file-list closed\"\n                : \"file-list\"\n            }\n          >\n            {Array.from(uploaderState.userFiles.entries()).map(\n              ([name, file]) => (\n                <FileListEntry\n                  key={name}\n                  name={name}\n                  file={file}\n                  selected={name === selectedLeft}\n                  selectFile={selectFile}\n                  removeFile={uploaderState.removeFile}\n                  renameFile={uploaderState.renameFile}\n                />\n              )\n            )}\n            <FileListAddButton onDrop={uploaderState.onDrop} />\n          </ul>\n          {selectedLeftFile ? (\n            <>\n              <div\n                className=\"file-heading\"\n                onClick={() => setLeftFilelistOpen(true)}\n              >\n                <div className=\"file-heading-inner\">{selectedLeft}</div>\n                <button onClick={() => setLeftFilelistOpen(true)}>\n                  <FontAwesomeIcon icon={faChevronDown} />\n                </button>\n              </div>\n              <SourceMappedText\n                text={new TextDecoder().decode(selectedLeftFile.content)}\n                mappings={mappings}\n                openRight={selectRightFile}\n                highlight={selectSegmentLeft}\n              />\n            </>\n          ) : null}\n        </div>\n        <div className=\"editor-source\">\n          <ul\n            className={\n              selectedRightFile &&\n              selectedRightFile.state !== \"missing\" &&\n              !rightFilelistOpen\n                ? \"file-list closed\"\n                : \"file-list\"\n            }\n          >\n            {Array.from(parseResult.sourceFiles.entries()).map(\n              ([name, file]) => (\n                <FileListEntry\n                  key={name}\n                  name={name}\n                  file={file}\n                  selected={false}\n                  selectFile={selectRightFile}\n                  removeFile={uploaderState.removeFile}\n                  renameFile={uploaderState.renameFile}\n                />\n              )\n            )}\n          </ul>\n          {selectedRightFile && selectedRightFile.state !== \"missing\" ? (\n            <>\n              <div\n                className=\"file-heading\"\n                onClick={() => setRightFilelistOpen(true)}\n              >\n                <div className=\"file-heading-inner\">{selectedRight}</div>\n                <button onClick={() => setRightFilelistOpen(true)}>\n                  <FontAwesomeIcon icon={faChevronDown} />\n                </button>\n              </div>\n              <SourceMappedText\n                text={new TextDecoder().decode(selectedRightFile.content)}\n                mappings={inversedMappings}\n                highlight={highlightRight}\n              />\n            </>\n          ) : null}\n        </div>\n      </div>\n    </div>\n  );\n};\n\ninterface FileListEntryProps {\n  name: string;\n  file: UserFileState | SourceFileState;\n  selected: boolean;\n  removeFile: (name: string) => void;\n  renameFile: (name: string, newName: string) => void;\n  selectFile?: (name: string) => void;\n}\n\nconst FileListEntry: React.FC<FileListEntryProps> = (props) => {\n  const { name, file, selected, removeFile, renameFile, selectFile } = props;\n  const [nameEditing, setNameEditing] = useState<string | undefined>();\n  const editable = file.state === \"uploaded\";\n  const editing = editable && !!nameEditing;\n  const classNames = [\n    \"file-list-entry\",\n    selected ? \"selected\" : undefined,\n  ].filter(Boolean);\n  return (\n    <li\n      className={classNames.join(\" \")}\n      onClick={(e) => {\n        if (!editing && selectFile) {\n          selectFile(name);\n        }\n      }}\n    >\n      <div className=\"file-list-entry-inner\">\n        {editing ? (\n          <input\n            type=\"text\"\n            className=\"file-list-name-input\"\n            value={nameEditing}\n            onChange={(e) => setNameEditing(e.currentTarget.value)}\n            onKeyPress={(e) => {\n              if (e.key === \"Enter\") {\n                renameFile(name, nameEditing ?? name);\n                setNameEditing(undefined);\n              }\n            }}\n            autoFocus={true}\n          />\n        ) : (\n          <span className=\"file-list-name\">{name}</span>\n        )}\n        {file.state === \"uploading\" ? \"...\" : \"\"}\n      </div>\n      {(file.state === \"uploaded\" || file.state === \"bundled\") && !editing ? (\n        <button\n          className=\"file-list-select\"\n          onClick={(e) => {\n            e.stopPropagation();\n            if (selectFile) selectFile(name);\n          }}\n        >\n          <FontAwesomeIcon icon={faCaretDown} />\n        </button>\n      ) : null}\n      {editing ? (\n        <>\n          <button\n            className=\"file-list-apply-edit\"\n            onClick={(e) => {\n              e.stopPropagation();\n              renameFile(name, nameEditing ?? name);\n              setNameEditing(undefined);\n            }}\n          >\n            <FontAwesomeIcon icon={faCheck} />\n          </button>\n          <button\n            className=\"file-list-cancel-edit\"\n            onClick={(e) => {\n              e.stopPropagation();\n              setNameEditing(undefined);\n            }}\n          >\n            <FontAwesomeIcon icon={faUndo} />\n          </button>\n        </>\n      ) : editable ? (\n        <button\n          className=\"file-list-edit\"\n          onClick={(e) => {\n            e.stopPropagation();\n            setNameEditing(name);\n          }}\n        >\n          <FontAwesomeIcon icon={faEdit} />\n        </button>\n      ) : null}\n      {file.state === \"uploading\" || file.state === \"uploaded\" ? (\n        <button\n          className=\"file-list-remove\"\n          onClick={(e) => {\n            e.stopPropagation();\n            removeFile(name);\n          }}\n        >\n          <FontAwesomeIcon icon={faTrash} />\n        </button>\n      ) : null}\n    </li>\n  );\n};\n\ninterface FileListAddButtonProps {\n  onDrop: (uploadedFiles: File[]) => void;\n}\n\nconst FileListAddButton: React.FC<FileListAddButtonProps> = (props) => {\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\n    onDrop: props.onDrop,\n  });\n  return (\n    <li className=\"file-list-add-button\" {...getRootProps()}>\n      <input {...getInputProps()} />\n      {isDragActive ? (\n        <div>Drop the files here ...</div>\n      ) : (\n        <span>Drag 'n' drop some files here, or click to select files</span>\n      )}\n    </li>\n  );\n};\n\ninterface SourceMappedTextProps {\n  text: string;\n  mappings?: Segment[][];\n  highlight?: [number, number];\n  openRight?: (\n    name: string,\n    highlight?: [[number, number], [number, number]]\n  ) => void;\n}\n\nconst SourceMappedText: React.FC<SourceMappedTextProps> = (props) => {\n  const mappings = props.mappings ?? [];\n  return (\n    <pre className=\"generated-file-content\">\n      <code>\n        {props.text.split(\"\\n\").map((line, lineno) => (\n          <SourceMappedLine\n            key={lineno}\n            lineno={lineno}\n            line={line}\n            mappings={mappings[lineno]}\n            highlight={\n              props.highlight\n                ? props.highlight[0] === lineno\n                  ? props.highlight[1]\n                  : undefined\n                : undefined\n            }\n            openRight={props.openRight}\n          />\n        ))}\n      </code>\n    </pre>\n  );\n};\n\ninterface SourceMappedLineProps {\n  lineno: number;\n  line: string;\n  mappings?: Segment[];\n  highlight?: number;\n  openRight?: (\n    name: string,\n    highlight?: [[number, number], [number, number]]\n  ) => void;\n}\n\nconst SourceMappedLine: React.FC<SourceMappedLineProps> = (props) => {\n  let mappings = props.mappings ?? [];\n  if (mappings.length === 0 || mappings[0].column > 0) {\n    mappings = [{ column: 0 }].concat(mappings);\n  }\n  return (\n    <>\n      {mappings.map((mapping, i) => {\n        const nextColumn = mappings[i + 1]?.column ?? props.line.length;\n        if (mapping.column >= nextColumn) return null;\n        const segmentText = props.line.substring(mapping.column, nextColumn);\n        return (\n          <SourceMappedSegment\n            key={mapping.column}\n            lineno={props.lineno}\n            segmentText={segmentText}\n            mapping={mapping}\n            highlight={props.highlight === mapping.column}\n            openRight={props.openRight}\n          />\n        );\n      })}\n      {\"\\n\"}\n    </>\n  );\n};\n\ninterface SourceMappedSegmentProps {\n  lineno: number;\n  segmentText: string;\n  mapping: Segment;\n  highlight: boolean;\n  openRight?: (\n    name: string,\n    highlight?: [[number, number], [number, number]]\n  ) => void;\n}\n\nconst SourceMappedSegment: React.FC<SourceMappedSegmentProps> = (props) => {\n  const { segmentText, mapping, highlight, openRight } = props;\n  const openThisRight = useCallback(() => {\n    if (openRight && mapping.source) {\n      openRight(mapping.source, [\n        [props.lineno, mapping.column],\n        [mapping.sourceLine, mapping.sourceColumn],\n      ]);\n    }\n  }, [\n    openRight,\n    mapping.source,\n    props.lineno,\n    mapping.column,\n    mapping.sourceLine,\n    mapping.sourceColumn,\n  ]);\n  const highlightRef = useRef<HTMLSpanElement>(null);\n  useEffect(() => {\n    if (highlight) {\n      highlightRef.current?.scrollIntoView({\n        block: \"nearest\",\n        inline: \"nearest\",\n      });\n    }\n  }, [highlight]);\n  if (mapping.source) {\n    return (\n      <span\n        className={highlight ? \"segment-mapped highlight\" : \"segment-mapped\"}\n        onClick={openThisRight}\n        ref={highlight ? highlightRef : undefined}\n      >\n        {segmentText}\n      </span>\n    );\n  } else {\n    return <span className=\"segment-unmapped\">{segmentText}</span>;\n  }\n};\n\nconst inverseMappings = (\n  name: string,\n  sourceName: string,\n  mappings: Segment[][]\n): Segment[][] => {\n  const newMappings: MappedSegment[][] = [];\n  for (const [lineno, line] of Array.from(mappings.entries())) {\n    for (const segment of line) {\n      if (!segment.source) continue;\n      if (segment.source !== sourceName) continue;\n      while (newMappings.length <= segment.sourceLine) newMappings.push([]);\n      newMappings[segment.sourceLine].push({\n        column: segment.sourceColumn,\n        source: name,\n        sourceLine: lineno,\n        sourceColumn: segment.column,\n      });\n    }\n  }\n  for (const line of newMappings) {\n    line.sort((a, b) => {\n      if (a.column !== b.column) return a.column - b.column;\n      // For sort reproducibility\n      if (a.sourceLine !== b.sourceLine) return a.sourceLine - b.sourceLine;\n      return a.sourceLine - b.sourceLine;\n    });\n  }\n  return newMappings;\n};\n\nexport default App;\n","import { useCallback, useState } from \"react\";\nimport { produce } from \"immer\";\nimport { UploadedFileState, UserFileState } from \"./file_states\";\n\nexport interface UploaderState {\n  userFiles: Map<string, UserFileState>;\n  uploadedFiles: Map<string, UploadedFileState>;\n  removeFile: (name: string) => void;\n  renameFile: (name: string, newName: string) => void;\n  onDrop: (acceptedFiles: File[]) => void;\n}\n\nexport const useUploader = (): UploaderState => {\n  const [userFiles, setUserFiles] = useState<Map<string, UserFileState>>(\n    () => new Map()\n  );\n  const removeFile = useCallback(\n    (name: string) => {\n      setUserFiles((state) =>\n        produce(state, (state) => {\n          state.delete(name);\n        })\n      );\n    },\n    [setUserFiles]\n  );\n  const renameFile = useCallback(\n    (name: string, newName: string) => {\n      setUserFiles((state) =>\n        produce(state, (state) => {\n          const entry = state.get(name);\n          if (entry && name !== newName) {\n            state.delete(name);\n            state.set(newName, entry);\n          }\n        })\n      );\n    },\n    [setUserFiles]\n  );\n  const onDrop = useCallback(\n    (acceptedFiles: File[]) => {\n      setUserFiles((state) =>\n        produce(state, (state) => {\n          for (const file of acceptedFiles) {\n            state.set(file.name, {\n              state: \"uploading\",\n              file,\n              content: state.get(file.name)?.content,\n            });\n          }\n        })\n      );\n      for (const file of acceptedFiles) {\n        (async (file) => {\n          const content = await file.arrayBuffer();\n          setUserFiles((state) =>\n            produce(state, (state) => {\n              const oldFileState = state.get(file.name);\n              if (\n                !oldFileState ||\n                oldFileState.state !== \"uploading\" ||\n                oldFileState.file !== file\n              ) {\n                return;\n              }\n              state.set(file.name, {\n                state: \"uploaded\",\n                content,\n              });\n            })\n          );\n        })(file);\n      }\n    },\n    [setUserFiles]\n  );\n\n  const uploadedFiles: Map<string, UploadedFileState> = new Map();\n  for (const [name, file] of Array.from(userFiles.entries())) {\n    if (file.content) {\n      uploadedFiles.set(name, {\n        state: \"uploaded\",\n        content: file.content,\n      });\n    }\n  }\n\n  return {\n    uploadedFiles,\n    userFiles,\n    removeFile,\n    renameFile,\n    onDrop,\n  };\n};\n","import { ReportHandler } from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { enableMapSet } from \"immer\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nenableMapSet();\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}